{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":1,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":1,"renderable":0},{"_id":"source/img/ironman-draw1.png","path":"img/ironman-draw1.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":1,"renderable":0},{"_id":"source/img/header_img/kobe.png","path":"img/header_img/kobe.png","modified":1,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":1,"renderable":0},{"_id":"source/img/home-bg-o.png","path":"img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":1,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1555395809733},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1555395809736},{"_id":"themes/beantech/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1555395809866},{"_id":"themes/beantech/_config.yml","hash":"f0796b8e85fe6b3154a5fa442420003fe18dff0a","modified":1555395809868},{"_id":"source/about/index.md","hash":"d4cf7207ded88c694ff6f620f36ce1b9774f1eee","modified":1555395809761},{"_id":"source/_discarded/你好，hexo.md","hash":"3e7f01133acbe41a3e062badf1a443919fbf7dbb","modified":1561797644701},{"_id":"source/_posts/JVM系列-垃圾回收器和内存分配.md","hash":"1e058a6b1247ea7c97a1afac95c53e9192ee80af","modified":1561798553785},{"_id":"source/_posts/Java并发工具-CountDownLatch、CyclicBarrier、Semaphore.md","hash":"afc8c598de2c32a40b7bde5b0fcfe5ef32398af3","modified":1561798439194},{"_id":"source/_posts/VA-对象序列化——Serializable.md","hash":"67d31e251d437ac3d3d70f8b76febc584ac2c420","modified":1561797369098},{"_id":"source/_posts/VM系列-JVM运行时内存区域.md","hash":"e87c46f762b9d3080649f65dc48cc7818ed44ba3","modified":1561798785566},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口.md","hash":"d917bdbb3388183f1d2aa1003166035df586f646","modified":1561797947303},{"_id":"source/_posts/ava虚拟机-Java代码是怎么运行的？.md","hash":"1393e5875b5af3b0d411770eaf177c74bf50951c","modified":1561797918962},{"_id":"source/_posts/hexo-theme-beantech.md","hash":"8077b5b81319a99fc6b28925b8463d0cf1f11091","modified":1561797537897},{"_id":"source/_posts/jvm类加载机制.md","hash":"7bfc74c6a104ee9b7f42b5d5394b1fc1e6fca30b","modified":1561798866873},{"_id":"source/_posts/jvm系列-垃圾收集器.md","hash":"5e497ab5dccb864b5ff80bf6de8d801ee62bf8be","modified":1561798627025},{"_id":"source/_posts/m系列-内存分配和回收策略.md","hash":"30aac6f5d8fcd70dd899912aea68dec827a990dc","modified":1561798820402},{"_id":"source/_posts/jvm系列-虚拟机性能监控工具.md","hash":"5d65ec89b5b221087a03cedd694153a40b7ae7f1","modified":1561798744734},{"_id":"source/_posts/titledjava基础之集合框架-HashMap深入理解及应用.md","hash":"90038a4ebb319a1ebb573b834aa1be7a7f029767","modified":1561797176317},{"_id":"source/_posts/va-concurrent包下的锁.md","hash":"862c10df96604a7865cecfb669295ab6e601dd9f","modified":1561798491986},{"_id":"source/_posts/va基础之集合框架-HashSet深入理解.md","hash":"395a5db533574c90b84021ce148eaf69b191d2d8","modified":1561797417170},{"_id":"source/_posts/va基础之集合框架-LinkedHashMap深入理解.md","hash":"a18718fd0d210b6a120275d888847dd58499da0a","modified":1561797531925},{"_id":"source/_posts/va并发编程-线程封闭.md","hash":"f63703dcd0ccf006f09d38de227a5a5e67f923e1","modified":1561797628565},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询.md","hash":"93a56a66fe54bffdbdea27a1f2b318c5086f76d6","modified":1561797968118},{"_id":"source/_posts/上传jar包到nexus私服.md","hash":"9d1ba093d97b4d9f437fb5563455eb3bbc2a550b","modified":1561799027918},{"_id":"source/_posts/利用jstack打印线程dump信息.md","hash":"59f1e84bd13da29ac36db5c066f5da414d715585","modified":1561798248992},{"_id":"source/_posts/操作原理.md","hash":"c203a9cb9774b523e8db7ace33da95ab0e0cf626","modified":1561798148169},{"_id":"source/_posts/算法与结构-插入排序.md","hash":"68cf58439afe3c91cb720fb1a6f66609be186d2d","modified":1561798984950},{"_id":"source/_posts/步队列-AbstractQueuedSyncronizer.md","hash":"5710991b756ca841df0ef28b268624329618ca53","modified":1561798316711},{"_id":"source/archive/index.md","hash":"21806fd262da492f2634d224f5846ccee9cd3b45","modified":1555395809763},{"_id":"source/_posts/算法与结构-选择排序.md","hash":"573b8bad2779755338d4dd23d5884be1502e6522","modified":1561798933321},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1555395809840},{"_id":"source/tags/index.md","hash":"a4cdcade4001fdc71547462e0bd7feedee96038b","modified":1555395809862},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1555395809871},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1555395809873},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1555395809875},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1555395809877},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1555395809880},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1555395809882},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1555395809884},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1555395809886},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1555395809888},{"_id":"themes/beantech/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1555395809892},{"_id":"themes/beantech/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1555395809924},{"_id":"themes/beantech/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1555395809926},{"_id":"themes/beantech/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1555395809928},{"_id":"themes/beantech/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1555395809931},{"_id":"themes/beantech/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1555395809933},{"_id":"themes/beantech/layout/page.ejs","hash":"f7fc5282ad55131aa67dcde03c9189faa450a7c9","modified":1555395809935},{"_id":"themes/beantech/layout/post.ejs","hash":"5a408fd5d759e70dc95c23a993550cee7d1c6cd5","modified":1555395809937},{"_id":"themes/beantech/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1555395809939},{"_id":"source/_discarded/ded/Untitled.md","hash":"ab15318924336ad9e0f101db6c95d0e4bf9df351","modified":1555583271907},{"_id":"source/_discarded/ded/深入理解jvm-堆栈及回收算法.md","hash":"701f73914e5f48d810515b2e0092f92d9efc4feb","modified":1561797751027},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1555395809768},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"6739744e71fc211a9e7c05c71c42b240c1f5abf7","modified":1555395809895},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"258af22c0c8d5dce3f218f4cc8b2220f38a841b9","modified":1555395809897},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"9aea336d3907735eedabcfb21c286cd54a01f45f","modified":1555395809900},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1555395809902},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1555395809907},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1555395809904},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"a765433a33b3613f4664de2da48d0c58f68f8cd6","modified":1555395809909},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1555395809911},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1555395809914},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"e29431fa78c81d7c521bb1f7be356651fcde959c","modified":1555395809916},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"b185fcffb0d181ddd9eb2259af38cf7d82fb2846","modified":1555395809918},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"814dd716083a8a75eb31f9d2d6ab28150b01c533","modified":1555395809920},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"91288381dbd98f1c6b91d419094934ff59437021","modified":1555395809922},{"_id":"themes/beantech/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1555395809943},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1555395809947},{"_id":"themes/beantech/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1555395809944},{"_id":"themes/beantech/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1555395809956},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1555395809958},{"_id":"themes/beantech/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1555395809965},{"_id":"themes/beantech/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1555395809967},{"_id":"themes/beantech/source/css/toc.styl","hash":"822aca17c885109452cc75a9aa384d9f3c07ea81","modified":1555395809969},{"_id":"themes/beantech/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1555395809971},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1555395809974},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1555395809980},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1555395809982},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1555395809985},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1555395809990},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1555395809995},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1555395809992},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1555395810004},{"_id":"themes/beantech/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1555395810009},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1555395810007},{"_id":"themes/beantech/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1555395810010},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1555395809785},{"_id":"source/img/ironman-draw.png","hash":"8edb8d0e75e27c727540a06e6b76de69b7348252","modified":1548591943607},{"_id":"source/img/ironman-draw1.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1555395809844},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1555395809952},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1555395809977},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1555395809988},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1555395810002},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1555395809754},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1555395809754},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1555395809754},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1555395809781},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1555395809857},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1555395809950},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1555395809961},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1555395809963},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1555395809758},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1555395809758},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1555395809758},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1555395809838},{"_id":"source/img/header_img/kobe.png","hash":"196d889db98fc89c469d7a80f2987d9620432dd4","modified":1548592038696},{"_id":"themes/beantech/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1555395809999},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1555395809850},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1555395809777},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1555395809834},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555395809750},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555395809750},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555395809750},{"_id":"source/img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1555395809824},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1555395809824},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1555395809812},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1555395809799}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2019-04-17T09:34:34.738Z","updated":"2019-04-16T06:23:29.733Z","path":"404.html","title":"","comments":1,"_id":"cjxhh9p720000kcx13b3hzkuo","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2019-04-16T06:23:29.761Z","path":"about/index.html","_id":"cjxhh9p7o0001kcx1soz091j5","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-04-16T06:23:29.763Z","path":"archive/index.html","_id":"cjxhh9p7u0003kcx1vspvdrpq","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2019-04-16T06:23:29.862Z","updated":"2019-04-16T06:23:29.862Z","path":"tags/index.html","comments":1,"_id":"cjxhh9p7w0005kcx16im9d9fm","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JVM系列--垃圾回收器和内存分配","catalog":true,"author":"wangmj","date":"2018-08-28T08:55:00.000Z","subtitle":null,"header-img":null,"_content":"### 判断对象是否存活\n\n - 引用计数法\n - 可达性分析算法\n ##### 引用计数法：\n 引用计数法主要为记录一个对象被引用的次数，当引用数大于0，则不会被垃圾回收；对象没被一次引用，则计数加1，对象失效时计数减一；这个方法对jvm回收来说非常高效，但是不会很准确，假如说两个对象互相引用，即使这两个对象没有其他地方应用，也会一直存在，不会被回收。\n ##### 可达性分析\n 可达性分析主要由JVM根据GC root为跟，依次向下找其引用的对象，所有在这个引用链上的对象都不会被回收，一些对象即使有引用链，但是其根节点不是GC Root对象，其也会被回收。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129155249143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\nGC Root的对象包括以下四种\n- 虚拟机栈所引用的对象\n- 静态变量所引用的对象\n- 常量所引用的对象\n- 本地方法栈所引用的对象\n\n对象即使没有在引用链上，也不会一次被判死刑，其会在finalize()方法中有一次escape gc 的机会。\n判断一个对象是否有finalize()逃生机会有两种，\n- 对象是否重写了finalize()方法\n- 对象是否经历过finalize()方法\n\n只有重写finalize()方法并且没有执行过finalize()方法才会有机会拯救自己，下面写一个程序验证。\n\n```\n/**\n * 对象重写finalize() escape GC\n * @author wangmj\n * @since 2019/1/28\n */\npublic class FinalizeEscapeGc {\n    public static FinalizeEscapeGc HOOK = null;\n\n    public void isAlive() {\n        System.out.println(\"i am alive\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"finalize executed start\");\n        super.finalize();\n        FinalizeEscapeGc.HOOK = this;\n        System.out.println(\"finalize executed end\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        HOOK = new FinalizeEscapeGc();\n        //对象没有可达性时，只有一次escape机会，\n        HOOK = null;\n        //会首先判断对象是否有必要执行finalize方法\n        //当对象没有覆盖finalize()方法或者对象没有调用过finalize()方法则认为没有必要执行\n        System.gc();\n        Thread.sleep(500);\n        //由于覆盖了finalize()方法并且第一次调用，所有对象成功escape\n        if (HOOK != null) {\n            HOOK.isAlive();\n        }else {\n            System.out.println(\"i am dead\");\n        }\n\n\n        HOOK = null;\n        System.gc();\n        Thread.sleep(500);\n        //对象已经调用一次，则不会再次调用finalize\n        if (HOOK != null) {\n            HOOK.isAlive();\n        }else {\n            System.out.println(\"i am dead\");\n        }\n    }\n}\n```\n执行结果\n\n```\nfinalize executed start\nfinalize executed end\ni am alive\ni am dead\n```\n### 垃圾收集算法\n- 标记清除算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129160615534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤：首先遍历查询所有有引用的对象进行标记，第二步遍历堆，把所有未标记的对象进行清除\n缺点：会产生内存碎片\n- 复制算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012916072959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤：需要同样大小的内存，先遍历所有的引用对象并进行复制，复制的同时进行碎片的整理，为了解决两倍大小的内存，设置堆内存的时候设置成Eden区和Survivor区域，复制的时候将存活的对象复制到Survivor区域\n缺点：需要两倍大小的内存\n- 标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129160942705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤；结合上面两种的算法，先遍历所有有引用的对象并对其标记；遍历所有堆中没有被引用的对象\t\t    并清除；对内存进行重新整理；\n缺点：复杂性提高\n","source":"_posts/JVM系列-垃圾回收器和内存分配.md","raw":"title: JVM系列--垃圾回收器和内存分配\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-08-28 16:55:00\nsubtitle:\nheader-img:\n---\n### 判断对象是否存活\n\n - 引用计数法\n - 可达性分析算法\n ##### 引用计数法：\n 引用计数法主要为记录一个对象被引用的次数，当引用数大于0，则不会被垃圾回收；对象没被一次引用，则计数加1，对象失效时计数减一；这个方法对jvm回收来说非常高效，但是不会很准确，假如说两个对象互相引用，即使这两个对象没有其他地方应用，也会一直存在，不会被回收。\n ##### 可达性分析\n 可达性分析主要由JVM根据GC root为跟，依次向下找其引用的对象，所有在这个引用链上的对象都不会被回收，一些对象即使有引用链，但是其根节点不是GC Root对象，其也会被回收。\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129155249143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\nGC Root的对象包括以下四种\n- 虚拟机栈所引用的对象\n- 静态变量所引用的对象\n- 常量所引用的对象\n- 本地方法栈所引用的对象\n\n对象即使没有在引用链上，也不会一次被判死刑，其会在finalize()方法中有一次escape gc 的机会。\n判断一个对象是否有finalize()逃生机会有两种，\n- 对象是否重写了finalize()方法\n- 对象是否经历过finalize()方法\n\n只有重写finalize()方法并且没有执行过finalize()方法才会有机会拯救自己，下面写一个程序验证。\n\n```\n/**\n * 对象重写finalize() escape GC\n * @author wangmj\n * @since 2019/1/28\n */\npublic class FinalizeEscapeGc {\n    public static FinalizeEscapeGc HOOK = null;\n\n    public void isAlive() {\n        System.out.println(\"i am alive\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"finalize executed start\");\n        super.finalize();\n        FinalizeEscapeGc.HOOK = this;\n        System.out.println(\"finalize executed end\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        HOOK = new FinalizeEscapeGc();\n        //对象没有可达性时，只有一次escape机会，\n        HOOK = null;\n        //会首先判断对象是否有必要执行finalize方法\n        //当对象没有覆盖finalize()方法或者对象没有调用过finalize()方法则认为没有必要执行\n        System.gc();\n        Thread.sleep(500);\n        //由于覆盖了finalize()方法并且第一次调用，所有对象成功escape\n        if (HOOK != null) {\n            HOOK.isAlive();\n        }else {\n            System.out.println(\"i am dead\");\n        }\n\n\n        HOOK = null;\n        System.gc();\n        Thread.sleep(500);\n        //对象已经调用一次，则不会再次调用finalize\n        if (HOOK != null) {\n            HOOK.isAlive();\n        }else {\n            System.out.println(\"i am dead\");\n        }\n    }\n}\n```\n执行结果\n\n```\nfinalize executed start\nfinalize executed end\ni am alive\ni am dead\n```\n### 垃圾收集算法\n- 标记清除算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129160615534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤：首先遍历查询所有有引用的对象进行标记，第二步遍历堆，把所有未标记的对象进行清除\n缺点：会产生内存碎片\n- 复制算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012916072959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤：需要同样大小的内存，先遍历所有的引用对象并进行复制，复制的同时进行碎片的整理，为了解决两倍大小的内存，设置堆内存的时候设置成Eden区和Survivor区域，复制的时候将存活的对象复制到Survivor区域\n缺点：需要两倍大小的内存\n- 标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129160942705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n步骤；结合上面两种的算法，先遍历所有有引用的对象并对其标记；遍历所有堆中没有被引用的对象\t\t    并清除；对内存进行重新整理；\n缺点：复杂性提高\n","slug":"JVM系列-垃圾回收器和内存分配","published":1,"updated":"2019-06-29T08:55:53.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p7p0002kcx1pij7kcjq","content":"<h3><span id=\"判断对象是否存活\">判断对象是否存活</span></h3>\n<ul>\n<li>引用计数法</li>\n<li>可达性分析算法</li>\n</ul>\n<h5><span id=\"引用计数法\">引用计数法：</span></h5>\n<p>引用计数法主要为记录一个对象被引用的次数，当引用数大于0，则不会被垃圾回收；对象没被一次引用，则计数加1，对象失效时计数减一；这个方法对jvm回收来说非常高效，但是不会很准确，假如说两个对象互相引用，即使这两个对象没有其他地方应用，也会一直存在，不会被回收。</p>\n<h5><span id=\"可达性分析\">可达性分析</span></h5>\n<p>可达性分析主要由JVM根据GC root为跟，依次向下找其引用的对象，所有在这个引用链上的对象都不会被回收，一些对象即使有引用链，但是其根节点不是GC Root对象，其也会被回收。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129155249143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\nGC Root的对象包括以下四种</p>\n<ul>\n<li>虚拟机栈所引用的对象</li>\n<li>静态变量所引用的对象</li>\n<li>常量所引用的对象</li>\n<li>本地方法栈所引用的对象</li>\n</ul>\n<p>对象即使没有在引用链上，也不会一次被判死刑，其会在finalize()方法中有一次escape gc 的机会。<br>\n判断一个对象是否有finalize()逃生机会有两种，</p>\n<ul>\n<li>对象是否重写了finalize()方法</li>\n<li>对象是否经历过finalize()方法</li>\n</ul>\n<p>只有重写finalize()方法并且没有执行过finalize()方法才会有机会拯救自己，下面写一个程序验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 对象重写finalize() escape GC</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/28</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FinalizeEscapeGc &#123;</span><br><span class=\"line\">    public static FinalizeEscapeGc HOOK = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void isAlive() &#123;</span><br><span class=\"line\">        System.out.println(&quot;i am alive&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void finalize() throws Throwable &#123;</span><br><span class=\"line\">        System.out.println(&quot;finalize executed start&quot;);</span><br><span class=\"line\">        super.finalize();</span><br><span class=\"line\">        FinalizeEscapeGc.HOOK = this;</span><br><span class=\"line\">        System.out.println(&quot;finalize executed end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        HOOK = new FinalizeEscapeGc();</span><br><span class=\"line\">        //对象没有可达性时，只有一次escape机会，</span><br><span class=\"line\">        HOOK = null;</span><br><span class=\"line\">        //会首先判断对象是否有必要执行finalize方法</span><br><span class=\"line\">        //当对象没有覆盖finalize()方法或者对象没有调用过finalize()方法则认为没有必要执行</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        //由于覆盖了finalize()方法并且第一次调用，所有对象成功escape</span><br><span class=\"line\">        if (HOOK != null) &#123;</span><br><span class=\"line\">            HOOK.isAlive();</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            System.out.println(&quot;i am dead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        HOOK = null;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        //对象已经调用一次，则不会再次调用finalize</span><br><span class=\"line\">        if (HOOK != null) &#123;</span><br><span class=\"line\">            HOOK.isAlive();</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            System.out.println(&quot;i am dead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalize executed start</span><br><span class=\"line\">finalize executed end</span><br><span class=\"line\">i am alive</span><br><span class=\"line\">i am dead</span><br></pre></td></tr></table></figure>\n<h3><span id=\"垃圾收集算法\">垃圾收集算法</span></h3>\n<ul>\n<li>标记清除算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129160615534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤：首先遍历查询所有有引用的对象进行标记，第二步遍历堆，把所有未标记的对象进行清除<br>\n缺点：会产生内存碎片</li>\n<li>复制算法<br>\n<img src=\"https://img-blog.csdnimg.cn/2019012916072959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤：需要同样大小的内存，先遍历所有的引用对象并进行复制，复制的同时进行碎片的整理，为了解决两倍大小的内存，设置堆内存的时候设置成Eden区和Survivor区域，复制的时候将存活的对象复制到Survivor区域<br>\n缺点：需要两倍大小的内存</li>\n<li>标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129160942705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤；结合上面两种的算法，先遍历所有有引用的对象并对其标记；遍历所有堆中没有被引用的对象\t\t    并清除；对内存进行重新整理；<br>\n缺点：复杂性提高</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>判断对象是否存活</h3>\n<ul>\n<li>引用计数法</li>\n<li>可达性分析算法</li>\n</ul>\n<h5>引用计数法：</h5>\n<p>引用计数法主要为记录一个对象被引用的次数，当引用数大于0，则不会被垃圾回收；对象没被一次引用，则计数加1，对象失效时计数减一；这个方法对jvm回收来说非常高效，但是不会很准确，假如说两个对象互相引用，即使这两个对象没有其他地方应用，也会一直存在，不会被回收。</p>\n<h5>可达性分析</h5>\n<p>可达性分析主要由JVM根据GC root为跟，依次向下找其引用的对象，所有在这个引用链上的对象都不会被回收，一些对象即使有引用链，但是其根节点不是GC Root对象，其也会被回收。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129155249143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\nGC Root的对象包括以下四种</p>\n<ul>\n<li>虚拟机栈所引用的对象</li>\n<li>静态变量所引用的对象</li>\n<li>常量所引用的对象</li>\n<li>本地方法栈所引用的对象</li>\n</ul>\n<p>对象即使没有在引用链上，也不会一次被判死刑，其会在finalize()方法中有一次escape gc 的机会。<br>\n判断一个对象是否有finalize()逃生机会有两种，</p>\n<ul>\n<li>对象是否重写了finalize()方法</li>\n<li>对象是否经历过finalize()方法</li>\n</ul>\n<p>只有重写finalize()方法并且没有执行过finalize()方法才会有机会拯救自己，下面写一个程序验证。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 对象重写finalize() escape GC</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/28</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FinalizeEscapeGc &#123;</span><br><span class=\"line\">    public static FinalizeEscapeGc HOOK = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void isAlive() &#123;</span><br><span class=\"line\">        System.out.println(&quot;i am alive&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void finalize() throws Throwable &#123;</span><br><span class=\"line\">        System.out.println(&quot;finalize executed start&quot;);</span><br><span class=\"line\">        super.finalize();</span><br><span class=\"line\">        FinalizeEscapeGc.HOOK = this;</span><br><span class=\"line\">        System.out.println(&quot;finalize executed end&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        HOOK = new FinalizeEscapeGc();</span><br><span class=\"line\">        //对象没有可达性时，只有一次escape机会，</span><br><span class=\"line\">        HOOK = null;</span><br><span class=\"line\">        //会首先判断对象是否有必要执行finalize方法</span><br><span class=\"line\">        //当对象没有覆盖finalize()方法或者对象没有调用过finalize()方法则认为没有必要执行</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        //由于覆盖了finalize()方法并且第一次调用，所有对象成功escape</span><br><span class=\"line\">        if (HOOK != null) &#123;</span><br><span class=\"line\">            HOOK.isAlive();</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            System.out.println(&quot;i am dead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        HOOK = null;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        Thread.sleep(500);</span><br><span class=\"line\">        //对象已经调用一次，则不会再次调用finalize</span><br><span class=\"line\">        if (HOOK != null) &#123;</span><br><span class=\"line\">            HOOK.isAlive();</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            System.out.println(&quot;i am dead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finalize executed start</span><br><span class=\"line\">finalize executed end</span><br><span class=\"line\">i am alive</span><br><span class=\"line\">i am dead</span><br></pre></td></tr></table></figure>\n<h3>垃圾收集算法</h3>\n<ul>\n<li>标记清除算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129160615534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤：首先遍历查询所有有引用的对象进行标记，第二步遍历堆，把所有未标记的对象进行清除<br>\n缺点：会产生内存碎片</li>\n<li>复制算法<br>\n<img src=\"https://img-blog.csdnimg.cn/2019012916072959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤：需要同样大小的内存，先遍历所有的引用对象并进行复制，复制的同时进行碎片的整理，为了解决两倍大小的内存，设置堆内存的时候设置成Eden区和Survivor区域，复制的时候将存活的对象复制到Survivor区域<br>\n缺点：需要两倍大小的内存</li>\n<li>标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129160942705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n步骤；结合上面两种的算法，先遍历所有有引用的对象并对其标记；遍历所有堆中没有被引用的对象\t\t    并清除；对内存进行重新整理；<br>\n缺点：复杂性提高</li>\n</ul>\n"},{"title":"Java并发工具-CountDownLatch、CyclicBarrier、Semaphore","catalog":true,"author":"wangmj","date":"2018-08-08T08:53:00.000Z","subtitle":null,"header-img":null,"_content":"### CountDownLatch等待线程完成\nCountDownLatch是一个等待所有线程完成的工具，类似join()方法，初始化的时候会调用构造器传递线程个数，调用countDown方法将count值减一，调用await方法会等待知道count=0才会通过。写一个简单的例子方便理解\n\n```\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * countDownLatch测试类\n *\n * @author wangmj\n * @since 2019/1/24\n */\npublic class CountDownLatchDemo {\n    private static CountDownLatch countDownLatch = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"线程1开始\");\n                countDownLatch.countDown();\n            }\n        }).start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程2开始\");\n                countDownLatch.countDown();\n            }\n        }).start();\n        //此时会等待线程1和线程2执行完才会执行下面代码\n        countDownLatch.await();\n        System.out.println(\"3\");\n    }\n}\n\n```\n\n### Semaphore 信号量\n信号量是一个可以控制同时有几个线程执行，其他线程等待的工具类，就好像一个门同时只有3个人通过，其他人则在门外等候，当三个人进门之后其他人才会下次三个进入门\n\n```\n\nimport java.util.concurrent.*;\n\n/**\n * @author wangmj\n * @since 2019/1/24\n */\npublic class SemaphoreDemo {\n\n    //同时只有三个线程执行\n    private static Semaphore semaphore = new Semaphore(3);\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(10);\n\n    public static void main(String[] args) {\n\n        long start = System.nanoTime();\n\n        for (int i = 0; i < 10; i++) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        semaphore.acquire();\n                        Thread.sleep(1000);\n                        System.out.println(\"thread name:\" + Thread.currentThread().getName()+\" and nanoTime:\"\n                                + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime()-start));\n                        semaphore.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n    }\n\n}\n```\n运行结果如下\n\n```\nthread name:pool-1-thread-3 and nanoTime:1\nthread name:pool-1-thread-2 and nanoTime:1\nthread name:pool-1-thread-1 and nanoTime:1\nthread name:pool-1-thread-5 and nanoTime:2\nthread name:pool-1-thread-4 and nanoTime:2\nthread name:pool-1-thread-6 and nanoTime:2\nthread name:pool-1-thread-7 and nanoTime:3\nthread name:pool-1-thread-8 and nanoTime:3\nthread name:pool-1-thread-9 and nanoTime:3\nthread name:pool-1-thread-10 and nanoTime:4\n```\n可以看到同一时间只允许三个线程运行，以上的原理都是基于AQS同步器实现的，可以参考我上两篇博客","source":"_posts/Java并发工具-CountDownLatch、CyclicBarrier、Semaphore.md","raw":"title: Java并发工具-CountDownLatch、CyclicBarrier、Semaphore\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-08-08 16:53:00\nsubtitle:\nheader-img:\n---\n### CountDownLatch等待线程完成\nCountDownLatch是一个等待所有线程完成的工具，类似join()方法，初始化的时候会调用构造器传递线程个数，调用countDown方法将count值减一，调用await方法会等待知道count=0才会通过。写一个简单的例子方便理解\n\n```\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * countDownLatch测试类\n *\n * @author wangmj\n * @since 2019/1/24\n */\npublic class CountDownLatchDemo {\n    private static CountDownLatch countDownLatch = new CountDownLatch(2);\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"线程1开始\");\n                countDownLatch.countDown();\n            }\n        }).start();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"线程2开始\");\n                countDownLatch.countDown();\n            }\n        }).start();\n        //此时会等待线程1和线程2执行完才会执行下面代码\n        countDownLatch.await();\n        System.out.println(\"3\");\n    }\n}\n\n```\n\n### Semaphore 信号量\n信号量是一个可以控制同时有几个线程执行，其他线程等待的工具类，就好像一个门同时只有3个人通过，其他人则在门外等候，当三个人进门之后其他人才会下次三个进入门\n\n```\n\nimport java.util.concurrent.*;\n\n/**\n * @author wangmj\n * @since 2019/1/24\n */\npublic class SemaphoreDemo {\n\n    //同时只有三个线程执行\n    private static Semaphore semaphore = new Semaphore(3);\n\n    private static ExecutorService executor = Executors.newFixedThreadPool(10);\n\n    public static void main(String[] args) {\n\n        long start = System.nanoTime();\n\n        for (int i = 0; i < 10; i++) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        semaphore.acquire();\n                        Thread.sleep(1000);\n                        System.out.println(\"thread name:\" + Thread.currentThread().getName()+\" and nanoTime:\"\n                                + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime()-start));\n                        semaphore.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n    }\n\n}\n```\n运行结果如下\n\n```\nthread name:pool-1-thread-3 and nanoTime:1\nthread name:pool-1-thread-2 and nanoTime:1\nthread name:pool-1-thread-1 and nanoTime:1\nthread name:pool-1-thread-5 and nanoTime:2\nthread name:pool-1-thread-4 and nanoTime:2\nthread name:pool-1-thread-6 and nanoTime:2\nthread name:pool-1-thread-7 and nanoTime:3\nthread name:pool-1-thread-8 and nanoTime:3\nthread name:pool-1-thread-9 and nanoTime:3\nthread name:pool-1-thread-10 and nanoTime:4\n```\n可以看到同一时间只允许三个线程运行，以上的原理都是基于AQS同步器实现的，可以参考我上两篇博客","slug":"Java并发工具-CountDownLatch、CyclicBarrier、Semaphore","published":1,"updated":"2019-06-29T08:53:59.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p7u0004kcx10oy0m5ny","content":"<h3><span id=\"countdownlatch等待线程完成\">CountDownLatch等待线程完成</span></h3>\n<p>CountDownLatch是一个等待所有线程完成的工具，类似join()方法，初始化的时候会调用构造器传递线程个数，调用countDown方法将count值减一，调用await方法会等待知道count=0才会通过。写一个简单的例子方便理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * countDownLatch测试类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/24</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLatchDemo &#123;</span><br><span class=\"line\">    private static CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(500);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(&quot;线程1开始&quot;);</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                System.out.println(&quot;线程2开始&quot;);</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        //此时会等待线程1和线程2执行完才会执行下面代码</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(&quot;3&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"semaphore-信号量\">Semaphore 信号量</span></h3>\n<p>信号量是一个可以控制同时有几个线程执行，其他线程等待的工具类，就好像一个门同时只有3个人通过，其他人则在门外等候，当三个人进门之后其他人才会下次三个进入门</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/24</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SemaphoreDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //同时只有三个线程执行</span><br><span class=\"line\">    private static Semaphore semaphore = new Semaphore(3);</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            executor.execute(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        semaphore.acquire();</span><br><span class=\"line\">                        Thread.sleep(1000);</span><br><span class=\"line\">                        System.out.println(&quot;thread name:&quot; + Thread.currentThread().getName()+&quot; and nanoTime:&quot;</span><br><span class=\"line\">                                + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime()-start));</span><br><span class=\"line\">                        semaphore.release();</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread name:pool-1-thread-3 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-2 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-1 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-5 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-4 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-6 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-7 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-8 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-9 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-10 and nanoTime:4</span><br></pre></td></tr></table></figure>\n<p>可以看到同一时间只允许三个线程运行，以上的原理都是基于AQS同步器实现的，可以参考我上两篇博客</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>CountDownLatch等待线程完成</h3>\n<p>CountDownLatch是一个等待所有线程完成的工具，类似join()方法，初始化的时候会调用构造器传递线程个数，调用countDown方法将count值减一，调用await方法会等待知道count=0才会通过。写一个简单的例子方便理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * countDownLatch测试类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/24</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLatchDemo &#123;</span><br><span class=\"line\">    private static CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(500);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(&quot;线程1开始&quot;);</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        new Thread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                System.out.println(&quot;线程2开始&quot;);</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        //此时会等待线程1和线程2执行完才会执行下面代码</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        System.out.println(&quot;3&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>Semaphore 信号量</h3>\n<p>信号量是一个可以控制同时有几个线程执行，其他线程等待的工具类，就好像一个门同时只有3个人通过，其他人则在门外等候，当三个人进门之后其他人才会下次三个进入门</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/24</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SemaphoreDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //同时只有三个线程执行</span><br><span class=\"line\">    private static Semaphore semaphore = new Semaphore(3);</span><br><span class=\"line\"></span><br><span class=\"line\">    private static ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            executor.execute(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        semaphore.acquire();</span><br><span class=\"line\">                        Thread.sleep(1000);</span><br><span class=\"line\">                        System.out.println(&quot;thread name:&quot; + Thread.currentThread().getName()+&quot; and nanoTime:&quot;</span><br><span class=\"line\">                                + TimeUnit.NANOSECONDS.toSeconds(System.nanoTime()-start));</span><br><span class=\"line\">                        semaphore.release();</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread name:pool-1-thread-3 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-2 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-1 and nanoTime:1</span><br><span class=\"line\">thread name:pool-1-thread-5 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-4 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-6 and nanoTime:2</span><br><span class=\"line\">thread name:pool-1-thread-7 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-8 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-9 and nanoTime:3</span><br><span class=\"line\">thread name:pool-1-thread-10 and nanoTime:4</span><br></pre></td></tr></table></figure>\n<p>可以看到同一时间只允许三个线程运行，以上的原理都是基于AQS同步器实现的，可以参考我上两篇博客</p>\n"},{"title":"JAVA 对象序列化——Serializable","catalog":true,"author":"wangmj","date":"2017-11-29T08:33:00.000Z","subtitle":null,"header-img":null,"_content":"##JAVA 对象序列化——Serializable\n上一篇分析HashMap时，每次put新值得时候将key、value放在一个transient Node[] table数组里面，大家注意到前面的关键字transient了吗？他代表什么意义呢；我们知道Map接口实现了顶级接口Serializable，表示Map对象的所有属性都是可序列化的，但是加上transient关键字就表示此属性不在被序列号。\n### serializable作用\nJava的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 只要对象实现了Serializable接口（记住，这个接口只是一个标记接口，不包含任何的方法）\n### serializable简单实现\n先建立一个简单类，实现Serializable接口\n```\npublic class Test implements Serializable {\n    private static final long serializeId = 129183856L;\n    private int i;\n    private String s;\n\n    public Test(int i, String s) {\n        this.i = i;\n        this.s = s;\n    }\n\n    @Override\n    public String toString() {\n        return \"Test{\" +\n                \"i=\" + i +\n                \", s='\" + s + '\\'' +\n                '}';\n    }\n}\n```\n如果我们想要序列化一个对象，首先要创建某些OutputStream(如FileOutputStream、ByteArrayOutputStream等)，然后将这些OutputStream封装在一个ObjectOutputStream中。这时候，只需要调用writeObject()方法就可以将对象序列化，并将其发送给OutputStream（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而饭序列的过程（即将一个序列还原成为一个对象），需要将一个InputStream(如FileInputstream、ByteArrayInputStream等)封装在ObjectInputStream内，然后调用readObject()即可。\n\n```\npublic class SerializeMain {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        Test test = new Test(1, \"ssss\");\n        System.out.println(test);\n        //序列化操作\n        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"test.out\"));\n        os.writeObject(\"======\");\n        os.writeObject(test);\n        os.close();\n\t\t//反序列化操作\n        ObjectInputStream oi = new ObjectInputStream((new FileInputStream(\"test.out\")));\n        String s = (String) oi.readObject();\n        Test t = (Test) oi.readObject();\n        System.out.println(s);\n        System.out.println(t);\n    }\n}\n```\n这时打印出信息为\n\n```\n======\nTest{i=1, s='ssss'}\n```\n\n若我们将Test类s属性改成private transient String s，再次运行主程序，此时我们打印的信息为\n\n```\n======\nTest{i=1, s='null'}\n```\n\n从上面结果能够看出来经过transient关键字修饰的字段是不能够被序列化的。\n\n### 为什么Node[]要加transient关键字\n怎么理解? 看一下HashMap.get()/put()知道, 读写Map是根据Object.hashcode()来确定从哪个bucket读/写. 而Object.hashcode()是native方法, 不同的JVM里可能是不一样的.\n\n打个比方说, 向HashMap存一个entry, key为 字符串\"STRING\", 在第一个java程序里, \"STRING\"的hashcode()为1, 存入第1号bucket; 在第二个java程序里, \"STRING\"的hashcode()有可能就是2, 存入第2号bucket. 如果用默认的串行化(Entry[] table不用transient), 那么这个HashMap从第一个java程序里通过串行化导入第二个java程序后, 其内存分布是一样的. 这就不对了. HashMap现在的readObject和writeObject是把内容 输出/输入, 把HashMap重新生成出来.","source":"_posts/VA-对象序列化——Serializable.md","raw":"title: JAVA 对象序列化——Serializable\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2017-11-29 16:33:00\nsubtitle:\nheader-img:\n---\n##JAVA 对象序列化——Serializable\n上一篇分析HashMap时，每次put新值得时候将key、value放在一个transient Node[] table数组里面，大家注意到前面的关键字transient了吗？他代表什么意义呢；我们知道Map接口实现了顶级接口Serializable，表示Map对象的所有属性都是可序列化的，但是加上transient关键字就表示此属性不在被序列号。\n### serializable作用\nJava的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 只要对象实现了Serializable接口（记住，这个接口只是一个标记接口，不包含任何的方法）\n### serializable简单实现\n先建立一个简单类，实现Serializable接口\n```\npublic class Test implements Serializable {\n    private static final long serializeId = 129183856L;\n    private int i;\n    private String s;\n\n    public Test(int i, String s) {\n        this.i = i;\n        this.s = s;\n    }\n\n    @Override\n    public String toString() {\n        return \"Test{\" +\n                \"i=\" + i +\n                \", s='\" + s + '\\'' +\n                '}';\n    }\n}\n```\n如果我们想要序列化一个对象，首先要创建某些OutputStream(如FileOutputStream、ByteArrayOutputStream等)，然后将这些OutputStream封装在一个ObjectOutputStream中。这时候，只需要调用writeObject()方法就可以将对象序列化，并将其发送给OutputStream（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而饭序列的过程（即将一个序列还原成为一个对象），需要将一个InputStream(如FileInputstream、ByteArrayInputStream等)封装在ObjectInputStream内，然后调用readObject()即可。\n\n```\npublic class SerializeMain {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        Test test = new Test(1, \"ssss\");\n        System.out.println(test);\n        //序列化操作\n        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"test.out\"));\n        os.writeObject(\"======\");\n        os.writeObject(test);\n        os.close();\n\t\t//反序列化操作\n        ObjectInputStream oi = new ObjectInputStream((new FileInputStream(\"test.out\")));\n        String s = (String) oi.readObject();\n        Test t = (Test) oi.readObject();\n        System.out.println(s);\n        System.out.println(t);\n    }\n}\n```\n这时打印出信息为\n\n```\n======\nTest{i=1, s='ssss'}\n```\n\n若我们将Test类s属性改成private transient String s，再次运行主程序，此时我们打印的信息为\n\n```\n======\nTest{i=1, s='null'}\n```\n\n从上面结果能够看出来经过transient关键字修饰的字段是不能够被序列化的。\n\n### 为什么Node[]要加transient关键字\n怎么理解? 看一下HashMap.get()/put()知道, 读写Map是根据Object.hashcode()来确定从哪个bucket读/写. 而Object.hashcode()是native方法, 不同的JVM里可能是不一样的.\n\n打个比方说, 向HashMap存一个entry, key为 字符串\"STRING\", 在第一个java程序里, \"STRING\"的hashcode()为1, 存入第1号bucket; 在第二个java程序里, \"STRING\"的hashcode()有可能就是2, 存入第2号bucket. 如果用默认的串行化(Entry[] table不用transient), 那么这个HashMap从第一个java程序里通过串行化导入第二个java程序后, 其内存分布是一样的. 这就不对了. HashMap现在的readObject和writeObject是把内容 输出/输入, 把HashMap重新生成出来.","slug":"VA-对象序列化——Serializable","published":1,"updated":"2019-06-29T08:36:09.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p7w0006kcx1i5wt22mv","content":"<p>##JAVA 对象序列化——Serializable<br>\n上一篇分析HashMap时，每次put新值得时候将key、value放在一个transient Node[] table数组里面，大家注意到前面的关键字transient了吗？他代表什么意义呢；我们知道Map接口实现了顶级接口Serializable，表示Map对象的所有属性都是可序列化的，但是加上transient关键字就表示此属性不在被序列号。</p>\n<h3><span id=\"serializable作用\">serializable作用</span></h3>\n<p>Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 只要对象实现了Serializable接口（记住，这个接口只是一个标记接口，不包含任何的方法）</p>\n<h3><span id=\"serializable简单实现\">serializable简单实现</span></h3>\n<p>先建立一个简单类，实现Serializable接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test implements Serializable &#123;</span><br><span class=\"line\">    private static final long serializeId = 129183856L;</span><br><span class=\"line\">    private int i;</span><br><span class=\"line\">    private String s;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Test(int i, String s) &#123;</span><br><span class=\"line\">        this.i = i;</span><br><span class=\"line\">        this.s = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Test&#123;&quot; +</span><br><span class=\"line\">                &quot;i=&quot; + i +</span><br><span class=\"line\">                &quot;, s=&apos;&quot; + s + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要序列化一个对象，首先要创建某些OutputStream(如FileOutputStream、ByteArrayOutputStream等)，然后将这些OutputStream封装在一个ObjectOutputStream中。这时候，只需要调用writeObject()方法就可以将对象序列化，并将其发送给OutputStream（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而饭序列的过程（即将一个序列还原成为一个对象），需要将一个InputStream(如FileInputstream、ByteArrayInputStream等)封装在ObjectInputStream内，然后调用readObject()即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SerializeMain &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        Test test = new Test(1, &quot;ssss&quot;);</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">        //序列化操作</span><br><span class=\"line\">        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));</span><br><span class=\"line\">        os.writeObject(&quot;======&quot;);</span><br><span class=\"line\">        os.writeObject(test);</span><br><span class=\"line\">        os.close();</span><br><span class=\"line\">\t\t//反序列化操作</span><br><span class=\"line\">        ObjectInputStream oi = new ObjectInputStream((new FileInputStream(&quot;test.out&quot;)));</span><br><span class=\"line\">        String s = (String) oi.readObject();</span><br><span class=\"line\">        Test t = (Test) oi.readObject();</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">        System.out.println(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时打印出信息为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======</span><br><span class=\"line\">Test&#123;i=1, s=&apos;ssss&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>若我们将Test类s属性改成private transient String s，再次运行主程序，此时我们打印的信息为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======</span><br><span class=\"line\">Test&#123;i=1, s=&apos;null&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面结果能够看出来经过transient关键字修饰的字段是不能够被序列化的。</p>\n<h3><span id=\"为什么node要加transient关键字\">为什么Node[]要加transient关键字</span></h3>\n<p>怎么理解? 看一下HashMap.get()/put()知道, 读写Map是根据Object.hashcode()来确定从哪个bucket读/写. 而Object.hashcode()是native方法, 不同的JVM里可能是不一样的.</p>\n<p>打个比方说, 向HashMap存一个entry, key为 字符串&quot;STRING&quot;, 在第一个java程序里, &quot;STRING&quot;的hashcode()为1, 存入第1号bucket; 在第二个java程序里, &quot;STRING&quot;的hashcode()有可能就是2, 存入第2号bucket. 如果用默认的串行化(Entry[] table不用transient), 那么这个HashMap从第一个java程序里通过串行化导入第二个java程序后, 其内存分布是一样的. 这就不对了. HashMap现在的readObject和writeObject是把内容 输出/输入, 把HashMap重新生成出来.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##JAVA 对象序列化——Serializable<br>\n上一篇分析HashMap时，每次put新值得时候将key、value放在一个transient Node[] table数组里面，大家注意到前面的关键字transient了吗？他代表什么意义呢；我们知道Map接口实现了顶级接口Serializable，表示Map对象的所有属性都是可序列化的，但是加上transient关键字就表示此属性不在被序列号。</p>\n<h3>serializable作用</h3>\n<p>Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 只要对象实现了Serializable接口（记住，这个接口只是一个标记接口，不包含任何的方法）</p>\n<h3>serializable简单实现</h3>\n<p>先建立一个简单类，实现Serializable接口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test implements Serializable &#123;</span><br><span class=\"line\">    private static final long serializeId = 129183856L;</span><br><span class=\"line\">    private int i;</span><br><span class=\"line\">    private String s;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Test(int i, String s) &#123;</span><br><span class=\"line\">        this.i = i;</span><br><span class=\"line\">        this.s = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Test&#123;&quot; +</span><br><span class=\"line\">                &quot;i=&quot; + i +</span><br><span class=\"line\">                &quot;, s=&apos;&quot; + s + &apos;\\&apos;&apos; +</span><br><span class=\"line\">                &apos;&#125;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想要序列化一个对象，首先要创建某些OutputStream(如FileOutputStream、ByteArrayOutputStream等)，然后将这些OutputStream封装在一个ObjectOutputStream中。这时候，只需要调用writeObject()方法就可以将对象序列化，并将其发送给OutputStream（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而饭序列的过程（即将一个序列还原成为一个对象），需要将一个InputStream(如FileInputstream、ByteArrayInputStream等)封装在ObjectInputStream内，然后调用readObject()即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SerializeMain &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        Test test = new Test(1, &quot;ssss&quot;);</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">        //序列化操作</span><br><span class=\"line\">        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;test.out&quot;));</span><br><span class=\"line\">        os.writeObject(&quot;======&quot;);</span><br><span class=\"line\">        os.writeObject(test);</span><br><span class=\"line\">        os.close();</span><br><span class=\"line\">\t\t//反序列化操作</span><br><span class=\"line\">        ObjectInputStream oi = new ObjectInputStream((new FileInputStream(&quot;test.out&quot;)));</span><br><span class=\"line\">        String s = (String) oi.readObject();</span><br><span class=\"line\">        Test t = (Test) oi.readObject();</span><br><span class=\"line\">        System.out.println(s);</span><br><span class=\"line\">        System.out.println(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时打印出信息为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======</span><br><span class=\"line\">Test&#123;i=1, s=&apos;ssss&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>若我们将Test类s属性改成private transient String s，再次运行主程序，此时我们打印的信息为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======</span><br><span class=\"line\">Test&#123;i=1, s=&apos;null&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面结果能够看出来经过transient关键字修饰的字段是不能够被序列化的。</p>\n<h3>为什么Node[]要加transient关键字</h3>\n<p>怎么理解? 看一下HashMap.get()/put()知道, 读写Map是根据Object.hashcode()来确定从哪个bucket读/写. 而Object.hashcode()是native方法, 不同的JVM里可能是不一样的.</p>\n<p>打个比方说, 向HashMap存一个entry, key为 字符串&quot;STRING&quot;, 在第一个java程序里, &quot;STRING&quot;的hashcode()为1, 存入第1号bucket; 在第二个java程序里, &quot;STRING&quot;的hashcode()有可能就是2, 存入第2号bucket. 如果用默认的串行化(Entry[] table不用transient), 那么这个HashMap从第一个java程序里通过串行化导入第二个java程序后, 其内存分布是一样的. 这就不对了. HashMap现在的readObject和writeObject是把内容 输出/输入, 把HashMap重新生成出来.</p>\n"},{"title":"JVM系列-JVM运行时内存区域","catalog":true,"author":"wangmj","date":"2018-08-11T08:54:00.000Z","subtitle":null,"header-img":null,"_content":"#### JVM运行时内存区域构成\n\n 1. 程序计数器\n 2. 虚拟机栈\n 3. 本地方法栈\n 4. 堆内存\n 5. 方法区\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190128142701453.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### 程序计数器\n程序计数器所占内存非常小，为**线程私有变量**，可以看住当前线程执行**行数**的记录，字节码解释器通过程序计数器来查找下一条指令，及线程恢复切换等操作。\n#### Java虚拟机栈\nJava虚拟机栈主要存放**基本类型变量**及**对象变量的内存地址**信息，为**线程私有变量**。每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表、方法出口等，此过程为压栈，当方法执行完毕会把此栈弹出，即出栈，所以其生命周期等同于变量的生命周期。\n当申请栈的深度大于虚拟机所允许的深度，将抛出**StackOverflowError**\n参数：**-Xss**\n#### 本地方法栈\nJava虚拟机栈包含本地房发栈，其主要存放native方法。\n#### Java堆内存\n堆内存是jvm管理的最大区域的内存，是线程共有的内存区域，主要存储对象变量；分为年轻代与年老代，年轻代分为Eden区域和From Survivor 和To Survivor区域，是垃圾回收主要回收管理的区域。\n当申请的堆内存大于允许的堆内存空间将抛出**OutOfMemoryError**异常,设置堆内存大小参数：**-Xms20M**(最小堆内存) **-Xmx20M**(最大堆内存)\n#### 方法区\n主要存放类信息、常量数据、永久数据，抛出**OutOfMemoryError**异常\n参数：**-MaxPermSize**\n\n#### OutOfMemoryError异常制造\n启动参数\n\n```\n-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=D:\\file\n```\n程序：\n\n```\n/**\n * @author wangmj\n * @since 2019/1/9\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        while (true) {\n            list.add(new HeapVo());\n        }\n    }\n}\n\n```\n程序打印信息：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190128151229812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)","source":"_posts/VM系列-JVM运行时内存区域.md","raw":"title: JVM系列-JVM运行时内存区域\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-08-11 16:54:00\nsubtitle:\nheader-img:\n---\n#### JVM运行时内存区域构成\n\n 1. 程序计数器\n 2. 虚拟机栈\n 3. 本地方法栈\n 4. 堆内存\n 5. 方法区\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190128142701453.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### 程序计数器\n程序计数器所占内存非常小，为**线程私有变量**，可以看住当前线程执行**行数**的记录，字节码解释器通过程序计数器来查找下一条指令，及线程恢复切换等操作。\n#### Java虚拟机栈\nJava虚拟机栈主要存放**基本类型变量**及**对象变量的内存地址**信息，为**线程私有变量**。每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表、方法出口等，此过程为压栈，当方法执行完毕会把此栈弹出，即出栈，所以其生命周期等同于变量的生命周期。\n当申请栈的深度大于虚拟机所允许的深度，将抛出**StackOverflowError**\n参数：**-Xss**\n#### 本地方法栈\nJava虚拟机栈包含本地房发栈，其主要存放native方法。\n#### Java堆内存\n堆内存是jvm管理的最大区域的内存，是线程共有的内存区域，主要存储对象变量；分为年轻代与年老代，年轻代分为Eden区域和From Survivor 和To Survivor区域，是垃圾回收主要回收管理的区域。\n当申请的堆内存大于允许的堆内存空间将抛出**OutOfMemoryError**异常,设置堆内存大小参数：**-Xms20M**(最小堆内存) **-Xmx20M**(最大堆内存)\n#### 方法区\n主要存放类信息、常量数据、永久数据，抛出**OutOfMemoryError**异常\n参数：**-MaxPermSize**\n\n#### OutOfMemoryError异常制造\n启动参数\n\n```\n-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=D:\\file\n```\n程序：\n\n```\n/**\n * @author wangmj\n * @since 2019/1/9\n */\npublic class OOMTest {\n    public static void main(String[] args) {\n        List list = new ArrayList();\n        while (true) {\n            list.add(new HeapVo());\n        }\n    }\n}\n\n```\n程序打印信息：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190128151229812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)","slug":"VM系列-JVM运行时内存区域","published":1,"updated":"2019-06-29T08:59:45.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p7y0007kcx1f8sk0rmq","content":"<h4><span id=\"jvm运行时内存区域构成\">JVM运行时内存区域构成</span></h4>\n<ol>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>堆内存</li>\n<li>方法区<br>\n<img src=\"https://img-blog.csdnimg.cn/20190128142701453.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<h4><span id=\"程序计数器\">程序计数器</span></h4>\n<p>程序计数器所占内存非常小，为<strong>线程私有变量</strong>，可以看住当前线程执行<strong>行数</strong>的记录，字节码解释器通过程序计数器来查找下一条指令，及线程恢复切换等操作。</p>\n<h4><span id=\"java虚拟机栈\">Java虚拟机栈</span></h4>\n<p>Java虚拟机栈主要存放<strong>基本类型变量</strong>及<strong>对象变量的内存地址</strong>信息，为<strong>线程私有变量</strong>。每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表、方法出口等，此过程为压栈，当方法执行完毕会把此栈弹出，即出栈，所以其生命周期等同于变量的生命周期。<br>\n当申请栈的深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong><br>\n参数：<strong>-Xss</strong></p>\n<h4><span id=\"本地方法栈\">本地方法栈</span></h4>\n<p>Java虚拟机栈包含本地房发栈，其主要存放native方法。</p>\n<h4><span id=\"java堆内存\">Java堆内存</span></h4>\n<p>堆内存是jvm管理的最大区域的内存，是线程共有的内存区域，主要存储对象变量；分为年轻代与年老代，年轻代分为Eden区域和From Survivor 和To Survivor区域，是垃圾回收主要回收管理的区域。<br>\n当申请的堆内存大于允许的堆内存空间将抛出<strong>OutOfMemoryError</strong>异常,设置堆内存大小参数：<strong>-Xms20M</strong>(最小堆内存) <strong>-Xmx20M</strong>(最大堆内存)</p>\n<h4><span id=\"方法区\">方法区</span></h4>\n<p>主要存放类信息、常量数据、永久数据，抛出<strong>OutOfMemoryError</strong>异常<br>\n参数：<strong>-MaxPermSize</strong></p>\n<h4><span id=\"outofmemoryerror异常制造\">OutOfMemoryError异常制造</span></h4>\n<p>启动参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=D:\\file</span><br></pre></td></tr></table></figure>\n<p>程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/9</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class OOMTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List list = new ArrayList();</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            list.add(new HeapVo());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序打印信息：<br>\n<img src=\"https://img-blog.csdnimg.cn/20190128151229812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4>JVM运行时内存区域构成</h4>\n<ol>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n<li>堆内存</li>\n<li>方法区<br>\n<img src=\"https://img-blog.csdnimg.cn/20190128142701453.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<h4>程序计数器</h4>\n<p>程序计数器所占内存非常小，为<strong>线程私有变量</strong>，可以看住当前线程执行<strong>行数</strong>的记录，字节码解释器通过程序计数器来查找下一条指令，及线程恢复切换等操作。</p>\n<h4>Java虚拟机栈</h4>\n<p>Java虚拟机栈主要存放<strong>基本类型变量</strong>及<strong>对象变量的内存地址</strong>信息，为<strong>线程私有变量</strong>。每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表、方法出口等，此过程为压栈，当方法执行完毕会把此栈弹出，即出栈，所以其生命周期等同于变量的生命周期。<br>\n当申请栈的深度大于虚拟机所允许的深度，将抛出<strong>StackOverflowError</strong><br>\n参数：<strong>-Xss</strong></p>\n<h4>本地方法栈</h4>\n<p>Java虚拟机栈包含本地房发栈，其主要存放native方法。</p>\n<h4>Java堆内存</h4>\n<p>堆内存是jvm管理的最大区域的内存，是线程共有的内存区域，主要存储对象变量；分为年轻代与年老代，年轻代分为Eden区域和From Survivor 和To Survivor区域，是垃圾回收主要回收管理的区域。<br>\n当申请的堆内存大于允许的堆内存空间将抛出<strong>OutOfMemoryError</strong>异常,设置堆内存大小参数：<strong>-Xms20M</strong>(最小堆内存) <strong>-Xmx20M</strong>(最大堆内存)</p>\n<h4>方法区</h4>\n<p>主要存放类信息、常量数据、永久数据，抛出<strong>OutOfMemoryError</strong>异常<br>\n参数：<strong>-MaxPermSize</strong></p>\n<h4>OutOfMemoryError异常制造</h4>\n<p>启动参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms20M -Xmx20M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=D:\\file</span><br></pre></td></tr></table></figure>\n<p>程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/9</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class OOMTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List list = new ArrayList();</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            list.add(new HeapVo());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序打印信息：<br>\n<img src=\"https://img-blog.csdnimg.cn/20190128151229812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"java虚拟机-- Java代码是怎么运行的？","catalog":true,"author":"wangmj","date":"2018-05-20T08:42:00.000Z","subtitle":null,"header-img":null,"_content":"从虚拟机角度来说，其将Java代码编码为class文件，并放在虚拟机中的方法区。\n\n运行时，当执行一个方法的时候，虚拟机会生产一个栈帧，可以不连续，当方法执行结束，将此栈帧弹出.\n\n虚拟机包含 堆、方法区。PC寄存器、Java方法栈、本地方法栈(用 C++ 写的 )\n","source":"_posts/ava虚拟机-Java代码是怎么运行的？.md","raw":"title: java虚拟机-- Java代码是怎么运行的？\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-05-20 16:42:00\nsubtitle:\nheader-img:\n---\n从虚拟机角度来说，其将Java代码编码为class文件，并放在虚拟机中的方法区。\n\n运行时，当执行一个方法的时候，虚拟机会生产一个栈帧，可以不连续，当方法执行结束，将此栈帧弹出.\n\n虚拟机包含 堆、方法区。PC寄存器、Java方法栈、本地方法栈(用 C++ 写的 )\n","slug":"ava虚拟机-Java代码是怎么运行的？","published":1,"updated":"2019-06-29T08:45:18.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p7z0008kcx1lgsa5bbb","content":"<p>从虚拟机角度来说，其将Java代码编码为class文件，并放在虚拟机中的方法区。</p>\n<p>运行时，当执行一个方法的时候，虚拟机会生产一个栈帧，可以不连续，当方法执行结束，将此栈帧弹出.</p>\n<p>虚拟机包含 堆、方法区。PC寄存器、Java方法栈、本地方法栈(用 C++ 写的 )</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从虚拟机角度来说，其将Java代码编码为class文件，并放在虚拟机中的方法区。</p>\n<p>运行时，当执行一个方法的时候，虚拟机会生产一个栈帧，可以不连续，当方法执行结束，将此栈帧弹出.</p>\n<p>虚拟机包含 堆、方法区。PC寄存器、Java方法栈、本地方法栈(用 C++ 写的 )</p>\n"},{"title":"[Hexo] Theme BeanTech","catalog":true,"subtitle":"This is hexo theme Demo.","header-img":"Demo.png","catagories":["Hexo"],"date":"2016-03-18T02:51:00.000Z","_content":"> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\nhttps://github.com/wmj765/wmj765.github.io.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/wmj765/wmj765.github.io\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/wmj765\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!","source":"_posts/hexo-theme-beantech.md","raw":"title: '[Hexo] Theme BeanTech'\ncatalog: true\nsubtitle: This is hexo theme Demo.\nheader-img: Demo.png\ntags:\n  - Hexo\n  - Blog\ncatagories:\n  - Hexo\ncategories: []\ndate: 2016-03-18 10:51:00\n---\n> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\nhttps://github.com/wmj765/wmj765.github.io.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/wmj765/wmj765.github.io\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/wmj765\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!","slug":"hexo-theme-beantech","published":1,"updated":"2019-06-29T08:38:57.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p830009kcx17lya320u","content":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><span id=\"live-demo\"></span></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1><span id=\"usage\">Usage</span></h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2><span id=\"init\">Init</span></h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/wmj765/wmj765.github.io.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2><span id=\"modify\">Modify</span></h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3><span id=\"deployment\">Deployment</span></h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"sidebar-settings\">Sidebar settings</span></h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3><span id=\"signature-setup\">Signature Setup</span></h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"go-to-top-icon-setup\">Go to top icon Setup</span></h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3><span id=\"post-tag\">Post tag</span></h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3><span id=\"markdown-render\">Markdown render</span></h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"hexo-basics\">Hexo Basics</span></h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"have-fun-_\">Have fun ^_^</span></h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/wmj765/wmj765.github.io\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/wmj765\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">Live Demo</a></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1>Usage</h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2>Init</h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/wmj765/wmj765.github.io.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2>Modify</h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3>Deployment</h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Sidebar settings</h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3>Signature Setup</h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Go to top icon Setup</h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3>Post tag</h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3>Markdown render</h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2>Hexo Basics</h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1>Have fun ^_^</h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/wmj765/wmj765.github.io\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/wmj765\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"java基础之集合框架--Collection及Map顶级接口","catalog":true,"author":"wangmj","header-img":"Demo.png","date":"2017-04-18T10:29:00.000Z","subtitle":null,"_content":"# java基础之集合框架--Collection及Map顶级接口\n\n最近看了百度的面试题，面试内容基本都是基础知识，好多问题没有答好，所以定个小目标，在年前争取把java主流的基础知识都巩固一遍；那就以使用最频繁的集合框架开始。\n\n\n## Collection及Map类图\n### collection类图\n![Collection类图](http://img.blog.csdn.net/20171030131133723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看出来，Collection下的子接口有三个分别为Set,List,Queue，其中Set为无序的且不可重复的集合，List为有序可重复的集合，queue为先入先出的队列。\n\n### Map类图\n![这里写图片描述](http://img.blog.csdn.net/20171030131940860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\ncollection接口主要包含的方法如下：add()、addAll()、contain()、remove()、hashCode()、size()、toArray()等方法\n\n关于Collection接口方面百度的技术面试主要问题：\nCollection有哪些子类或者子接口（上面图即是常用的）；\n问：接口可以定义常量么？\n答：接口肯定是可以定义常量的，并且只能定义常量，但是其实接口中定义公有常量是不推荐的，除非这个常量与这个接口及其实现的子类有非常密切的关系，如integer的最大值等；effectiveJava一书中也明确表示不建议定义常量接口，实现常量接口会把实现细节暴露到导出的API中，并会对实现此接口的配置类造成污染。\n还有一些特别基础的问题如：抽象类与接口的区别；为什么要用接口；为什么是单继承等；\n还有一个面试题说的是==与equals的区别（String a=\"s\"），这个其实很重要，对下面介绍set、map等结构有非常重要的作用；下面就解析下这道题。\n\n### equals与==区别\n介绍之前，先说明下，java的类型包括两类，一个为基础数据类型，一个为引用类型；在没有重写equals的方法情况下，equals与==比较结果相同，都是对引用地址的比较；基础数据类型都重写了equals方法，拿string类来说，它重写了object的equals方法\n\n```\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        //在不想等的情况下，判断是否为String类型，若为String类，则比较两个值是否想到\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n下面来分析下怎么来比较两个内存地址是否相同呢？有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：\n\n```\nstatic inline intptr_t get_next_hash(Thread * Self, oop obj) {\n  intptr_t value = 0 ;\n  if (hashCode == 0) {\n     // This form uses an unguarded global Park-Miller RNG,\n     // so it's possible for two threads to race and generate the same RNG.\n     // On MP system we'll have lots of RW access to a global, so the\n     // mechanism induces lots of coherency traffic.\n     value = os::random() ;\n  } else\n  if (hashCode == 1) {\n     // This variation has the property of being stable (idempotent)\n     // between STW operations.  This can be useful in some of the 1-0\n     // synchronization schemes.\n     intptr_t addrBits = intptr_t(obj) >> 3 ;\n     value = addrBits ^ (addrBits >> 5) ^ GVars.stwRandom ;\n  } else\n  if (hashCode == 2) {\n     value = 1 ;            // for sensitivity testing\n  } else\n  if (hashCode == 3) {\n     value = ++GVars.hcSequence ;\n  } else\n  if (hashCode == 4) {\n     value = intptr_t(obj) ;\n  } else {\n     // Marsaglia's xor-shift scheme with thread-specific state\n     // This is probably the best overall implementation -- we'll\n     // likely make this the default in future releases.\n     unsigned t = Self->_hashStateX ;\n     t ^= (t << 11) ;\n     Self->_hashStateX = Self->_hashStateY ;\n     Self->_hashStateY = Self->_hashStateZ ;\n     Self->_hashStateZ = Self->_hashStateW ;\n     unsigned v = Self->_hashStateW ;\n     v = (v ^ (v >> 19)) ^ (t ^ (t >> 8)) ;\n     Self->_hashStateW = v ;\n     value = v ;\n  }\n \n  value &= markOopDesc::hash_mask;\n  if (value == 0) value = 0xBAD ;\n  assert (value != markOopDesc::no_hash, \"invariant\") ;\n  TEVENT (hashCode: GENERATE) ;\n  return value;\n}\n```\n　因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。\n\n　　也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；\n\n　　如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；\n\n　　如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；\n\n　　如果两个对象的hashcode值相等，则equals方法得到的结果未知。\n\n以上即为Collection接口的基础知识，及百度一些面试题，下一章将介绍map接口及其子类，因为set是基于map实现的，懂得map的原理也就明白了set的原理","source":"_posts/ava基础之集合框架-Collection及Map顶级接口.md","raw":"title: java基础之集合框架--Collection及Map顶级接口\ncatalog: true\nauthor: wangmj\nheader-img: Demo.png\ntags: []\ncategories: []\ndate: 2017-04-18 18:29:00\nsubtitle:\n---\n# java基础之集合框架--Collection及Map顶级接口\n\n最近看了百度的面试题，面试内容基本都是基础知识，好多问题没有答好，所以定个小目标，在年前争取把java主流的基础知识都巩固一遍；那就以使用最频繁的集合框架开始。\n\n\n## Collection及Map类图\n### collection类图\n![Collection类图](http://img.blog.csdn.net/20171030131133723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看出来，Collection下的子接口有三个分别为Set,List,Queue，其中Set为无序的且不可重复的集合，List为有序可重复的集合，queue为先入先出的队列。\n\n### Map类图\n![这里写图片描述](http://img.blog.csdn.net/20171030131940860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\ncollection接口主要包含的方法如下：add()、addAll()、contain()、remove()、hashCode()、size()、toArray()等方法\n\n关于Collection接口方面百度的技术面试主要问题：\nCollection有哪些子类或者子接口（上面图即是常用的）；\n问：接口可以定义常量么？\n答：接口肯定是可以定义常量的，并且只能定义常量，但是其实接口中定义公有常量是不推荐的，除非这个常量与这个接口及其实现的子类有非常密切的关系，如integer的最大值等；effectiveJava一书中也明确表示不建议定义常量接口，实现常量接口会把实现细节暴露到导出的API中，并会对实现此接口的配置类造成污染。\n还有一些特别基础的问题如：抽象类与接口的区别；为什么要用接口；为什么是单继承等；\n还有一个面试题说的是==与equals的区别（String a=\"s\"），这个其实很重要，对下面介绍set、map等结构有非常重要的作用；下面就解析下这道题。\n\n### equals与==区别\n介绍之前，先说明下，java的类型包括两类，一个为基础数据类型，一个为引用类型；在没有重写equals的方法情况下，equals与==比较结果相同，都是对引用地址的比较；基础数据类型都重写了equals方法，拿string类来说，它重写了object的equals方法\n\n```\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        //在不想等的情况下，判断是否为String类型，若为String类，则比较两个值是否想到\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n下面来分析下怎么来比较两个内存地址是否相同呢？有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：\n\n```\nstatic inline intptr_t get_next_hash(Thread * Self, oop obj) {\n  intptr_t value = 0 ;\n  if (hashCode == 0) {\n     // This form uses an unguarded global Park-Miller RNG,\n     // so it's possible for two threads to race and generate the same RNG.\n     // On MP system we'll have lots of RW access to a global, so the\n     // mechanism induces lots of coherency traffic.\n     value = os::random() ;\n  } else\n  if (hashCode == 1) {\n     // This variation has the property of being stable (idempotent)\n     // between STW operations.  This can be useful in some of the 1-0\n     // synchronization schemes.\n     intptr_t addrBits = intptr_t(obj) >> 3 ;\n     value = addrBits ^ (addrBits >> 5) ^ GVars.stwRandom ;\n  } else\n  if (hashCode == 2) {\n     value = 1 ;            // for sensitivity testing\n  } else\n  if (hashCode == 3) {\n     value = ++GVars.hcSequence ;\n  } else\n  if (hashCode == 4) {\n     value = intptr_t(obj) ;\n  } else {\n     // Marsaglia's xor-shift scheme with thread-specific state\n     // This is probably the best overall implementation -- we'll\n     // likely make this the default in future releases.\n     unsigned t = Self->_hashStateX ;\n     t ^= (t << 11) ;\n     Self->_hashStateX = Self->_hashStateY ;\n     Self->_hashStateY = Self->_hashStateZ ;\n     Self->_hashStateZ = Self->_hashStateW ;\n     unsigned v = Self->_hashStateW ;\n     v = (v ^ (v >> 19)) ^ (t ^ (t >> 8)) ;\n     Self->_hashStateW = v ;\n     value = v ;\n  }\n \n  value &= markOopDesc::hash_mask;\n  if (value == 0) value = 0xBAD ;\n  assert (value != markOopDesc::no_hash, \"invariant\") ;\n  TEVENT (hashCode: GENERATE) ;\n  return value;\n}\n```\n　因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。\n\n　　也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；\n\n　　如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；\n\n　　如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；\n\n　　如果两个对象的hashcode值相等，则equals方法得到的结果未知。\n\n以上即为Collection接口的基础知识，及百度一些面试题，下一章将介绍map接口及其子类，因为set是基于map实现的，懂得map的原理也就明白了set的原理","slug":"ava基础之集合框架-Collection及Map顶级接口","published":1,"updated":"2019-06-29T08:45:47.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p87000akcx131dwp3ku","content":"<h1><span id=\"java基础之集合框架collection及map顶级接口\">java基础之集合框架–Collection及Map顶级接口</span></h1>\n<p>最近看了百度的面试题，面试内容基本都是基础知识，好多问题没有答好，所以定个小目标，在年前争取把java主流的基础知识都巩固一遍；那就以使用最频繁的集合框架开始。</p>\n<h2><span id=\"collection及map类图\">Collection及Map类图</span></h2>\n<h3><span id=\"collection类图\">collection类图</span></h3>\n<p><img src=\"http://img.blog.csdn.net/20171030131133723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Collection类图\"></p>\n<p>可以看出来，Collection下的子接口有三个分别为Set,List,Queue，其中Set为无序的且不可重复的集合，List为有序可重复的集合，queue为先入先出的队列。</p>\n<h3><span id=\"map类图\">Map类图</span></h3>\n<p><img src=\"http://img.blog.csdn.net/20171030131940860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>collection接口主要包含的方法如下：add()、addAll()、contain()、remove()、hashCode()、size()、toArray()等方法</p>\n<p>关于Collection接口方面百度的技术面试主要问题：<br>\nCollection有哪些子类或者子接口（上面图即是常用的）；<br>\n问：接口可以定义常量么？<br>\n答：接口肯定是可以定义常量的，并且只能定义常量，但是其实接口中定义公有常量是不推荐的，除非这个常量与这个接口及其实现的子类有非常密切的关系，如integer的最大值等；effectiveJava一书中也明确表示不建议定义常量接口，实现常量接口会把实现细节暴露到导出的API中，并会对实现此接口的配置类造成污染。<br>\n还有一些特别基础的问题如：抽象类与接口的区别；为什么要用接口；为什么是单继承等；<br>\n还有一个面试题说的是==与equals的区别（String a=“s”），这个其实很重要，对下面介绍set、map等结构有非常重要的作用；下面就解析下这道题。</p>\n<h3><span id=\"equals与区别\">equals与==区别</span></h3>\n<p>介绍之前，先说明下，java的类型包括两类，一个为基础数据类型，一个为引用类型；在没有重写equals的方法情况下，equals与==比较结果相同，都是对引用地址的比较；基础数据类型都重写了equals方法，拿string类来说，它重写了object的equals方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object anObject) &#123;</span><br><span class=\"line\">        if (this == anObject) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //在不想等的情况下，判断是否为String类型，若为String类，则比较两个值是否想到</span><br><span class=\"line\">        if (anObject instanceof String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            int n = value.length;</span><br><span class=\"line\">            if (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                char v1[] = value;</span><br><span class=\"line\">                char v2[] = anotherString.value;</span><br><span class=\"line\">                int i = 0;</span><br><span class=\"line\">                while (n-- != 0) &#123;</span><br><span class=\"line\">                    if (v1[i] != v2[i])</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>下面来分析下怎么来比较两个内存地址是否相同呢？有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline intptr_t get_next_hash(Thread * Self, oop obj) &#123;</span><br><span class=\"line\">  intptr_t value = 0 ;</span><br><span class=\"line\">  if (hashCode == 0) &#123;</span><br><span class=\"line\">     // This form uses an unguarded global Park-Miller RNG,</span><br><span class=\"line\">     // so it&apos;s possible for two threads to race and generate the same RNG.</span><br><span class=\"line\">     // On MP system we&apos;ll have lots of RW access to a global, so the</span><br><span class=\"line\">     // mechanism induces lots of coherency traffic.</span><br><span class=\"line\">     value = os::random() ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 1) &#123;</span><br><span class=\"line\">     // This variation has the property of being stable (idempotent)</span><br><span class=\"line\">     // between STW operations.  This can be useful in some of the 1-0</span><br><span class=\"line\">     // synchronization schemes.</span><br><span class=\"line\">     intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ;</span><br><span class=\"line\">     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 2) &#123;</span><br><span class=\"line\">     value = 1 ;            // for sensitivity testing</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 3) &#123;</span><br><span class=\"line\">     value = ++GVars.hcSequence ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 4) &#123;</span><br><span class=\"line\">     value = intptr_t(obj) ;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">     // Marsaglia&apos;s xor-shift scheme with thread-specific state</span><br><span class=\"line\">     // This is probably the best overall implementation -- we&apos;ll</span><br><span class=\"line\">     // likely make this the default in future releases.</span><br><span class=\"line\">     unsigned t = Self-&gt;_hashStateX ;</span><br><span class=\"line\">     t ^= (t &lt;&lt; 11) ;</span><br><span class=\"line\">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class=\"line\">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class=\"line\">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class=\"line\">     unsigned v = Self-&gt;_hashStateW ;</span><br><span class=\"line\">     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;</span><br><span class=\"line\">     Self-&gt;_hashStateW = v ;</span><br><span class=\"line\">     value = v ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  value &amp;= markOopDesc::hash_mask;</span><br><span class=\"line\">  if (value == 0) value = 0xBAD ;</span><br><span class=\"line\">  assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ;</span><br><span class=\"line\">  TEVENT (hashCode: GENERATE) ;</span><br><span class=\"line\">  return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</p>\n<p>也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；</p>\n<p>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</p>\n<p>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</p>\n<p>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</p>\n<p>以上即为Collection接口的基础知识，及百度一些面试题，下一章将介绍map接口及其子类，因为set是基于map实现的，懂得map的原理也就明白了set的原理</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>java基础之集合框架–Collection及Map顶级接口</h1>\n<p>最近看了百度的面试题，面试内容基本都是基础知识，好多问题没有答好，所以定个小目标，在年前争取把java主流的基础知识都巩固一遍；那就以使用最频繁的集合框架开始。</p>\n<h2>Collection及Map类图</h2>\n<h3>collection类图</h3>\n<p><img src=\"http://img.blog.csdn.net/20171030131133723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Collection类图\"></p>\n<p>可以看出来，Collection下的子接口有三个分别为Set,List,Queue，其中Set为无序的且不可重复的集合，List为有序可重复的集合，queue为先入先出的队列。</p>\n<h3>Map类图</h3>\n<p><img src=\"http://img.blog.csdn.net/20171030131940860?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>collection接口主要包含的方法如下：add()、addAll()、contain()、remove()、hashCode()、size()、toArray()等方法</p>\n<p>关于Collection接口方面百度的技术面试主要问题：<br>\nCollection有哪些子类或者子接口（上面图即是常用的）；<br>\n问：接口可以定义常量么？<br>\n答：接口肯定是可以定义常量的，并且只能定义常量，但是其实接口中定义公有常量是不推荐的，除非这个常量与这个接口及其实现的子类有非常密切的关系，如integer的最大值等；effectiveJava一书中也明确表示不建议定义常量接口，实现常量接口会把实现细节暴露到导出的API中，并会对实现此接口的配置类造成污染。<br>\n还有一些特别基础的问题如：抽象类与接口的区别；为什么要用接口；为什么是单继承等；<br>\n还有一个面试题说的是==与equals的区别（String a=“s”），这个其实很重要，对下面介绍set、map等结构有非常重要的作用；下面就解析下这道题。</p>\n<h3>equals与==区别</h3>\n<p>介绍之前，先说明下，java的类型包括两类，一个为基础数据类型，一个为引用类型；在没有重写equals的方法情况下，equals与==比较结果相同，都是对引用地址的比较；基础数据类型都重写了equals方法，拿string类来说，它重写了object的equals方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object anObject) &#123;</span><br><span class=\"line\">        if (this == anObject) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //在不想等的情况下，判断是否为String类型，若为String类，则比较两个值是否想到</span><br><span class=\"line\">        if (anObject instanceof String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            int n = value.length;</span><br><span class=\"line\">            if (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                char v1[] = value;</span><br><span class=\"line\">                char v2[] = anotherString.value;</span><br><span class=\"line\">                int i = 0;</span><br><span class=\"line\">                while (n-- != 0) &#123;</span><br><span class=\"line\">                    if (v1[i] != v2[i])</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>下面来分析下怎么来比较两个内存地址是否相同呢？有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。下面是HotSpot JVM中生成hash散列值的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static inline intptr_t get_next_hash(Thread * Self, oop obj) &#123;</span><br><span class=\"line\">  intptr_t value = 0 ;</span><br><span class=\"line\">  if (hashCode == 0) &#123;</span><br><span class=\"line\">     // This form uses an unguarded global Park-Miller RNG,</span><br><span class=\"line\">     // so it&apos;s possible for two threads to race and generate the same RNG.</span><br><span class=\"line\">     // On MP system we&apos;ll have lots of RW access to a global, so the</span><br><span class=\"line\">     // mechanism induces lots of coherency traffic.</span><br><span class=\"line\">     value = os::random() ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 1) &#123;</span><br><span class=\"line\">     // This variation has the property of being stable (idempotent)</span><br><span class=\"line\">     // between STW operations.  This can be useful in some of the 1-0</span><br><span class=\"line\">     // synchronization schemes.</span><br><span class=\"line\">     intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ;</span><br><span class=\"line\">     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 2) &#123;</span><br><span class=\"line\">     value = 1 ;            // for sensitivity testing</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 3) &#123;</span><br><span class=\"line\">     value = ++GVars.hcSequence ;</span><br><span class=\"line\">  &#125; else</span><br><span class=\"line\">  if (hashCode == 4) &#123;</span><br><span class=\"line\">     value = intptr_t(obj) ;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">     // Marsaglia&apos;s xor-shift scheme with thread-specific state</span><br><span class=\"line\">     // This is probably the best overall implementation -- we&apos;ll</span><br><span class=\"line\">     // likely make this the default in future releases.</span><br><span class=\"line\">     unsigned t = Self-&gt;_hashStateX ;</span><br><span class=\"line\">     t ^= (t &lt;&lt; 11) ;</span><br><span class=\"line\">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class=\"line\">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class=\"line\">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class=\"line\">     unsigned v = Self-&gt;_hashStateW ;</span><br><span class=\"line\">     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;</span><br><span class=\"line\">     Self-&gt;_hashStateW = v ;</span><br><span class=\"line\">     value = v ;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  value &amp;= markOopDesc::hash_mask;</span><br><span class=\"line\">  if (value == 0) value = 0xBAD ;</span><br><span class=\"line\">  assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ;</span><br><span class=\"line\">  TEVENT (hashCode: GENERATE) ;</span><br><span class=\"line\">  return value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</p>\n<p>也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；</p>\n<p>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</p>\n<p>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</p>\n<p>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</p>\n<p>以上即为Collection接口的基础知识，及百度一些面试题，下一章将介绍map接口及其子类，因为set是基于map实现的，懂得map的原理也就明白了set的原理</p>\n"},{"title":"jvm类加载机制","catalog":true,"author":"wangmj","date":"2018-11-30T09:00:00.000Z","subtitle":null,"header-img":null,"_content":"### 类加载时机\n类从被加载到虚拟机内存，到卸载出内存，要经历的**生命周期：**\n加载(Loading)=>验证(Verification)=>准备(Preparing)=>解析(Resolving)=>初始化(Initialization)=>使用(Using)=>卸载(Unloading)，其中验证、准备、解析成为连接阶段，可以参考netty里面的过程来记忆，netty中接收数据后会先进行接收数据，此过程对应加载过程；当接收完数据我们要来看下协议是否符合我们定义的数据协议，包括魔数、版本号等等，此阶段对应验证阶段；准备阶段主要是开辟内存并且设置类变量初始值阶段；当我们验证数据通过后，我们会按照协议来解析命令，此时对应解析阶段；当解析完成后，当我们用到这个类的时候就会进行初始化。下面具体介绍下类加载的具体过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190217193404859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n### 类加载过程\n#### 加载\n在加载阶段，虚拟机需要完成以下3件事情\n- 通过类的全限定名将类转化成二进制流\n- 将二进制流转化成运行时数据结构\n- 在方法区中实例化一个java.lang.class对象，作为访问类的入口\n\n加载没有完成连接可能已经开始，但是加载与连接的开始时间肯定是加载在前，连接在后；\n#### 验证\n验证阶段主要工作是验证类是否符合jvm规范，主要由下面四个内容来进行验证\n- **文件格式验证**\n主要包括魔数、版本号等等验证\n- **元数据验证**\n是否有父类子类、是否是抽象类、类中的字段等验证\n- **字节码验证**\n这个阶段主要是对类中的方法体进行验证\n- **符号引用验证**\n主要验证private、public等是否合法\n#### 准备\n准备阶段主要是对类中的变量分配内存并初始化值的过程，8中基本变量的初始值基本都为0，除了Boolean 变量为false；\n#### 解析\n解析过程是将符号引用转化为直接引用的过程，可以理解为将类和类中的变量解析成内存中的变量过程。\n#### 初始化\n初始化是执行类构造器方法的过程\n\n### 类加载器\n类加载器就是将类的全限定名转化成二进制流的Java外部实现的模块，类加载器应用在OSGI、热部署、代码加密等领域。\n自定义类加载过程\n\n```\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * @author wangmj\n * @since 2019/2/17\n */\npublic class ClassLoaderDemo {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        ClassLoader classLoader = new ClassLoader() {\n            @Override\n            public Class<?> loadClass(String name) throws ClassNotFoundException {\n                try {\n                    String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n                    InputStream inputStream = getClass().getResourceAsStream(fileName);\n                    if (inputStream == null) {\n                        return super.loadClass(name);\n                    }\n                    byte[] bytes = new byte[inputStream.available()];\n                    inputStream.read(bytes);\n                    return defineClass(name, bytes, 0, bytes.length);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    throw new ClassNotFoundException(name);\n                }\n            }\n        };\n        Object instance = classLoader.loadClass(\"com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo\").newInstance();\n        System.out.println(instance.getClass());\n        System.out.println(instance instanceof com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo);\n    }\n}\n```\n#### 双亲委派模式\n双亲委派模式在加载类的时候不会先在自己定义的加载方法执行，而是先去父类中的classLoader方法加载，这样好处就是所有子类最终都会实现最顶层父类的类加载器，这样不会导致因不同之类定义不同的类加载器导致各个类的结果不一样的情况。\n#### 非双亲委派模式\nJNDI、JDBC等都是非双亲委派模式，JNDI需要加载外部代码来实现相应功能，但是启动类加载器不识别这些代码，只能由父类加载器调用子类的加载器来实现，违背了由下到上的原则，但是增加了灵活性。\nOSGI、热部署等动态加载是进一步的非双亲委派模式，OSGI有bundle概念，每个bundle有自己的类加载器，当一个bundle被替换时，会同时替换类加载器，有点类似微服务的模块化","source":"_posts/jvm类加载机制.md","raw":"title: jvm类加载机制\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-11-30 17:00:00\nsubtitle:\nheader-img:\n---\n### 类加载时机\n类从被加载到虚拟机内存，到卸载出内存，要经历的**生命周期：**\n加载(Loading)=>验证(Verification)=>准备(Preparing)=>解析(Resolving)=>初始化(Initialization)=>使用(Using)=>卸载(Unloading)，其中验证、准备、解析成为连接阶段，可以参考netty里面的过程来记忆，netty中接收数据后会先进行接收数据，此过程对应加载过程；当接收完数据我们要来看下协议是否符合我们定义的数据协议，包括魔数、版本号等等，此阶段对应验证阶段；准备阶段主要是开辟内存并且设置类变量初始值阶段；当我们验证数据通过后，我们会按照协议来解析命令，此时对应解析阶段；当解析完成后，当我们用到这个类的时候就会进行初始化。下面具体介绍下类加载的具体过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190217193404859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n### 类加载过程\n#### 加载\n在加载阶段，虚拟机需要完成以下3件事情\n- 通过类的全限定名将类转化成二进制流\n- 将二进制流转化成运行时数据结构\n- 在方法区中实例化一个java.lang.class对象，作为访问类的入口\n\n加载没有完成连接可能已经开始，但是加载与连接的开始时间肯定是加载在前，连接在后；\n#### 验证\n验证阶段主要工作是验证类是否符合jvm规范，主要由下面四个内容来进行验证\n- **文件格式验证**\n主要包括魔数、版本号等等验证\n- **元数据验证**\n是否有父类子类、是否是抽象类、类中的字段等验证\n- **字节码验证**\n这个阶段主要是对类中的方法体进行验证\n- **符号引用验证**\n主要验证private、public等是否合法\n#### 准备\n准备阶段主要是对类中的变量分配内存并初始化值的过程，8中基本变量的初始值基本都为0，除了Boolean 变量为false；\n#### 解析\n解析过程是将符号引用转化为直接引用的过程，可以理解为将类和类中的变量解析成内存中的变量过程。\n#### 初始化\n初始化是执行类构造器方法的过程\n\n### 类加载器\n类加载器就是将类的全限定名转化成二进制流的Java外部实现的模块，类加载器应用在OSGI、热部署、代码加密等领域。\n自定义类加载过程\n\n```\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * @author wangmj\n * @since 2019/2/17\n */\npublic class ClassLoaderDemo {\n    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        ClassLoader classLoader = new ClassLoader() {\n            @Override\n            public Class<?> loadClass(String name) throws ClassNotFoundException {\n                try {\n                    String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\";\n                    InputStream inputStream = getClass().getResourceAsStream(fileName);\n                    if (inputStream == null) {\n                        return super.loadClass(name);\n                    }\n                    byte[] bytes = new byte[inputStream.available()];\n                    inputStream.read(bytes);\n                    return defineClass(name, bytes, 0, bytes.length);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    throw new ClassNotFoundException(name);\n                }\n            }\n        };\n        Object instance = classLoader.loadClass(\"com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo\").newInstance();\n        System.out.println(instance.getClass());\n        System.out.println(instance instanceof com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo);\n    }\n}\n```\n#### 双亲委派模式\n双亲委派模式在加载类的时候不会先在自己定义的加载方法执行，而是先去父类中的classLoader方法加载，这样好处就是所有子类最终都会实现最顶层父类的类加载器，这样不会导致因不同之类定义不同的类加载器导致各个类的结果不一样的情况。\n#### 非双亲委派模式\nJNDI、JDBC等都是非双亲委派模式，JNDI需要加载外部代码来实现相应功能，但是启动类加载器不识别这些代码，只能由父类加载器调用子类的加载器来实现，违背了由下到上的原则，但是增加了灵活性。\nOSGI、热部署等动态加载是进一步的非双亲委派模式，OSGI有bundle概念，每个bundle有自己的类加载器，当一个bundle被替换时，会同时替换类加载器，有点类似微服务的模块化","slug":"jvm类加载机制","published":1,"updated":"2019-06-29T09:01:06.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8b000ckcx17ifik2mo","content":"<h3><span id=\"类加载时机\">类加载时机</span></h3>\n<p>类从被加载到虚拟机内存，到卸载出内存，要经历的<strong>生命周期：</strong><br>\n加载(Loading)=&gt;验证(Verification)=&gt;准备(Preparing)=&gt;解析(Resolving)=&gt;初始化(Initialization)=&gt;使用(Using)=&gt;卸载(Unloading)，其中验证、准备、解析成为连接阶段，可以参考netty里面的过程来记忆，netty中接收数据后会先进行接收数据，此过程对应加载过程；当接收完数据我们要来看下协议是否符合我们定义的数据协议，包括魔数、版本号等等，此阶段对应验证阶段；准备阶段主要是开辟内存并且设置类变量初始值阶段；当我们验证数据通过后，我们会按照协议来解析命令，此时对应解析阶段；当解析完成后，当我们用到这个类的时候就会进行初始化。下面具体介绍下类加载的具体过程<br>\n<img src=\"https://img-blog.csdnimg.cn/20190217193404859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3><span id=\"类加载过程\">类加载过程</span></h3>\n<h4><span id=\"加载\">加载</span></h4>\n<p>在加载阶段，虚拟机需要完成以下3件事情</p>\n<ul>\n<li>通过类的全限定名将类转化成二进制流</li>\n<li>将二进制流转化成运行时数据结构</li>\n<li>在方法区中实例化一个java.lang.class对象，作为访问类的入口</li>\n</ul>\n<p>加载没有完成连接可能已经开始，但是加载与连接的开始时间肯定是加载在前，连接在后；</p>\n<h4><span id=\"验证\">验证</span></h4>\n<p>验证阶段主要工作是验证类是否符合jvm规范，主要由下面四个内容来进行验证</p>\n<ul>\n<li><strong>文件格式验证</strong><br>\n主要包括魔数、版本号等等验证</li>\n<li><strong>元数据验证</strong><br>\n是否有父类子类、是否是抽象类、类中的字段等验证</li>\n<li><strong>字节码验证</strong><br>\n这个阶段主要是对类中的方法体进行验证</li>\n<li><strong>符号引用验证</strong><br>\n主要验证private、public等是否合法</li>\n</ul>\n<h4><span id=\"准备\">准备</span></h4>\n<p>准备阶段主要是对类中的变量分配内存并初始化值的过程，8中基本变量的初始值基本都为0，除了Boolean 变量为false；</p>\n<h4><span id=\"解析\">解析</span></h4>\n<p>解析过程是将符号引用转化为直接引用的过程，可以理解为将类和类中的变量解析成内存中的变量过程。</p>\n<h4><span id=\"初始化\">初始化</span></h4>\n<p>初始化是执行类构造器方法的过程</p>\n<h3><span id=\"类加载器\">类加载器</span></h3>\n<p>类加载器就是将类的全限定名转化成二进制流的Java外部实现的模块，类加载器应用在OSGI、热部署、代码加密等领域。<br>\n自定义类加载过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/2/17</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ClassLoaderDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class=\"line\">        ClassLoader classLoader = new ClassLoader() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class=\"line\">                    InputStream inputStream = getClass().getResourceAsStream(fileName);</span><br><span class=\"line\">                    if (inputStream == null) &#123;</span><br><span class=\"line\">                        return super.loadClass(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    byte[] bytes = new byte[inputStream.available()];</span><br><span class=\"line\">                    inputStream.read(bytes);</span><br><span class=\"line\">                    return defineClass(name, bytes, 0, bytes.length);</span><br><span class=\"line\">                &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    throw new ClassNotFoundException(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Object instance = classLoader.loadClass(&quot;com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo&quot;).newInstance();</span><br><span class=\"line\">        System.out.println(instance.getClass());</span><br><span class=\"line\">        System.out.println(instance instanceof com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"双亲委派模式\">双亲委派模式</span></h4>\n<p>双亲委派模式在加载类的时候不会先在自己定义的加载方法执行，而是先去父类中的classLoader方法加载，这样好处就是所有子类最终都会实现最顶层父类的类加载器，这样不会导致因不同之类定义不同的类加载器导致各个类的结果不一样的情况。</p>\n<h4><span id=\"非双亲委派模式\">非双亲委派模式</span></h4>\n<p>JNDI、JDBC等都是非双亲委派模式，JNDI需要加载外部代码来实现相应功能，但是启动类加载器不识别这些代码，只能由父类加载器调用子类的加载器来实现，违背了由下到上的原则，但是增加了灵活性。<br>\nOSGI、热部署等动态加载是进一步的非双亲委派模式，OSGI有bundle概念，每个bundle有自己的类加载器，当一个bundle被替换时，会同时替换类加载器，有点类似微服务的模块化</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>类加载时机</h3>\n<p>类从被加载到虚拟机内存，到卸载出内存，要经历的<strong>生命周期：</strong><br>\n加载(Loading)=&gt;验证(Verification)=&gt;准备(Preparing)=&gt;解析(Resolving)=&gt;初始化(Initialization)=&gt;使用(Using)=&gt;卸载(Unloading)，其中验证、准备、解析成为连接阶段，可以参考netty里面的过程来记忆，netty中接收数据后会先进行接收数据，此过程对应加载过程；当接收完数据我们要来看下协议是否符合我们定义的数据协议，包括魔数、版本号等等，此阶段对应验证阶段；准备阶段主要是开辟内存并且设置类变量初始值阶段；当我们验证数据通过后，我们会按照协议来解析命令，此时对应解析阶段；当解析完成后，当我们用到这个类的时候就会进行初始化。下面具体介绍下类加载的具体过程<br>\n<img src=\"https://img-blog.csdnimg.cn/20190217193404859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3>类加载过程</h3>\n<h4>加载</h4>\n<p>在加载阶段，虚拟机需要完成以下3件事情</p>\n<ul>\n<li>通过类的全限定名将类转化成二进制流</li>\n<li>将二进制流转化成运行时数据结构</li>\n<li>在方法区中实例化一个java.lang.class对象，作为访问类的入口</li>\n</ul>\n<p>加载没有完成连接可能已经开始，但是加载与连接的开始时间肯定是加载在前，连接在后；</p>\n<h4>验证</h4>\n<p>验证阶段主要工作是验证类是否符合jvm规范，主要由下面四个内容来进行验证</p>\n<ul>\n<li><strong>文件格式验证</strong><br>\n主要包括魔数、版本号等等验证</li>\n<li><strong>元数据验证</strong><br>\n是否有父类子类、是否是抽象类、类中的字段等验证</li>\n<li><strong>字节码验证</strong><br>\n这个阶段主要是对类中的方法体进行验证</li>\n<li><strong>符号引用验证</strong><br>\n主要验证private、public等是否合法</li>\n</ul>\n<h4>准备</h4>\n<p>准备阶段主要是对类中的变量分配内存并初始化值的过程，8中基本变量的初始值基本都为0，除了Boolean 变量为false；</p>\n<h4>解析</h4>\n<p>解析过程是将符号引用转化为直接引用的过程，可以理解为将类和类中的变量解析成内存中的变量过程。</p>\n<h4>初始化</h4>\n<p>初始化是执行类构造器方法的过程</p>\n<h3>类加载器</h3>\n<p>类加载器就是将类的全限定名转化成二进制流的Java外部实现的模块，类加载器应用在OSGI、热部署、代码加密等领域。<br>\n自定义类加载过程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.InputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/2/17</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ClassLoaderDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class=\"line\">        ClassLoader classLoader = new ClassLoader() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;</span><br><span class=\"line\">                    InputStream inputStream = getClass().getResourceAsStream(fileName);</span><br><span class=\"line\">                    if (inputStream == null) &#123;</span><br><span class=\"line\">                        return super.loadClass(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    byte[] bytes = new byte[inputStream.available()];</span><br><span class=\"line\">                    inputStream.read(bytes);</span><br><span class=\"line\">                    return defineClass(name, bytes, 0, bytes.length);</span><br><span class=\"line\">                &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    throw new ClassNotFoundException(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Object instance = classLoader.loadClass(&quot;com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo&quot;).newInstance();</span><br><span class=\"line\">        System.out.println(instance.getClass());</span><br><span class=\"line\">        System.out.println(instance instanceof com.spring.cloud.moudle.study.demo.jvm.ClassLoaderDemo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>双亲委派模式</h4>\n<p>双亲委派模式在加载类的时候不会先在自己定义的加载方法执行，而是先去父类中的classLoader方法加载，这样好处就是所有子类最终都会实现最顶层父类的类加载器，这样不会导致因不同之类定义不同的类加载器导致各个类的结果不一样的情况。</p>\n<h4>非双亲委派模式</h4>\n<p>JNDI、JDBC等都是非双亲委派模式，JNDI需要加载外部代码来实现相应功能，但是启动类加载器不识别这些代码，只能由父类加载器调用子类的加载器来实现，违背了由下到上的原则，但是增加了灵活性。<br>\nOSGI、热部署等动态加载是进一步的非双亲委派模式，OSGI有bundle概念，每个bundle有自己的类加载器，当一个bundle被替换时，会同时替换类加载器，有点类似微服务的模块化</p>\n"},{"title":"jvm系列--内存分配和回收策略","catalog":true,"author":"wangmj","date":"2018-10-29T08:57:00.000Z","subtitle":null,"header-img":null,"_content":"### 对象优先在Eden区分配\n对象的内存分配，大方向上就是在堆上进行分配，当Eden区中没有足够的空间分配时，会进行一次minor GC--年轻代GC。\n写一段测试代码来测试下\n参数：\n\n```\n-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC\n```\n\n```\n/**\n * @author wangmj\n * @since 2019/1/29\n */\npublic class EdenGCDemo {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1, allocation2, allocation3, allocation4;\n\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[2 * _1MB];\n        allocation3 = new byte[2 * _1MB];\n        //发生minor Gc\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n运行结果\n\n```\n[GC (Allocation Failure) [DefNew: 6270K->705K(9216K), 0.0334506 secs] 6270K->4801K(19456K), 0.0335107 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] \nHeap\n def new generation   total 9216K, used 7172K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff250ed0, 0x00000000ff400000)\n  from space 1024K,  68% used [0x00000000ff500000, 0x00000000ff5b04e0, 0x00000000ff600000)\n  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)\n Metaspace       used 3421K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K\n```\n可以看出发生了一次minor GC，Eden内存由6M变成几乎为0，堆内存由6M变成了5M(?为甚么堆内存会减小，没想明白？)。我们看到form Survivor内存增加了将近1M， 老年代内存增加了4M。说明最后的4M直接被分配到了老年代。\n当老年代所剩的内存区域小于新生代区域并且小于平均每次收集新生代区域的平均值则会发生majorGC/fullGC,我们将上面代码简单修改下即可验证\n\n```\n/**\n * @author wangmj\n * @since 2019/1/29\n */\npublic class EdenGCDemo {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1, allocation2, allocation3, allocation4;\n\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[3 * _1MB];\n        //此时发生minorGC\n        allocation3 = new byte[2 * _1MB];\n        //发生majorGC\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n执行结果\n\n```\n\"C:\\Program Files\\Java\\jdk1.8.0_161\\bin\\java\" -Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\lib\\idea_rt.jar=51703:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\rt.jar;D:\\workspace\\personalpj\\spring-cloud-servers\\spring-cloud-moudle\\spring-cloud-moudle-study\\target\\classes\" com.spring.cloud.moudle.study.demo.jvm.EdenGCDemo\n[GC (Allocation Failure) [PSYoungGen: 7306K->840K(9216K)] 7306K->5968K(19456K), 0.0032098 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 840K->0K(9216K)] [ParOldGen: 5128K->5824K(10240K)] 5968K->5824K(19456K), [Metaspace: 3397K->3397K(1056768K)], 0.0074300 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 9216K, used 6468K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc510c8,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n ParOldGen       total 10240K, used 5824K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff1b02c8,0x00000000ff600000)\n Metaspace       used 3428K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 372K, capacity 388K, committed 512K, reserved 1048576K\n```\n可以看出先是发生了一次minorGC然后又发生了一次fullGC\n### 大对象直接进入老年代\n当对象足够大以至于Eden区域没有连续的足够区域来容纳，对象将直接分配到老年代，我们写段代码来测试\n\n### 长期存活的对象将放入到老年代中\n当年龄超过15岁的对象会被放入到老年代中","source":"_posts/m系列-内存分配和回收策略.md","raw":"title: jvm系列--内存分配和回收策略\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-10-29 16:57:00\nsubtitle:\nheader-img:\n---\n### 对象优先在Eden区分配\n对象的内存分配，大方向上就是在堆上进行分配，当Eden区中没有足够的空间分配时，会进行一次minor GC--年轻代GC。\n写一段测试代码来测试下\n参数：\n\n```\n-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC\n```\n\n```\n/**\n * @author wangmj\n * @since 2019/1/29\n */\npublic class EdenGCDemo {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1, allocation2, allocation3, allocation4;\n\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[2 * _1MB];\n        allocation3 = new byte[2 * _1MB];\n        //发生minor Gc\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n运行结果\n\n```\n[GC (Allocation Failure) [DefNew: 6270K->705K(9216K), 0.0334506 secs] 6270K->4801K(19456K), 0.0335107 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] \nHeap\n def new generation   total 9216K, used 7172K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff250ed0, 0x00000000ff400000)\n  from space 1024K,  68% used [0x00000000ff500000, 0x00000000ff5b04e0, 0x00000000ff600000)\n  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)\n tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)\n Metaspace       used 3421K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K\n```\n可以看出发生了一次minor GC，Eden内存由6M变成几乎为0，堆内存由6M变成了5M(?为甚么堆内存会减小，没想明白？)。我们看到form Survivor内存增加了将近1M， 老年代内存增加了4M。说明最后的4M直接被分配到了老年代。\n当老年代所剩的内存区域小于新生代区域并且小于平均每次收集新生代区域的平均值则会发生majorGC/fullGC,我们将上面代码简单修改下即可验证\n\n```\n/**\n * @author wangmj\n * @since 2019/1/29\n */\npublic class EdenGCDemo {\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) {\n        byte[] allocation1, allocation2, allocation3, allocation4;\n\n        allocation1 = new byte[2 * _1MB];\n        allocation2 = new byte[3 * _1MB];\n        //此时发生minorGC\n        allocation3 = new byte[2 * _1MB];\n        //发生majorGC\n        allocation4 = new byte[4 * _1MB];\n    }\n}\n```\n执行结果\n\n```\n\"C:\\Program Files\\Java\\jdk1.8.0_161\\bin\\java\" -Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\lib\\idea_rt.jar=51703:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\rt.jar;D:\\workspace\\personalpj\\spring-cloud-servers\\spring-cloud-moudle\\spring-cloud-moudle-study\\target\\classes\" com.spring.cloud.moudle.study.demo.jvm.EdenGCDemo\n[GC (Allocation Failure) [PSYoungGen: 7306K->840K(9216K)] 7306K->5968K(19456K), 0.0032098 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n[Full GC (Ergonomics) [PSYoungGen: 840K->0K(9216K)] [ParOldGen: 5128K->5824K(10240K)] 5968K->5824K(19456K), [Metaspace: 3397K->3397K(1056768K)], 0.0074300 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] \nHeap\n PSYoungGen      total 9216K, used 6468K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)\n  eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc510c8,0x00000000ffe00000)\n  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)\n  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)\n ParOldGen       total 10240K, used 5824K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)\n  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff1b02c8,0x00000000ff600000)\n Metaspace       used 3428K, capacity 4496K, committed 4864K, reserved 1056768K\n  class space    used 372K, capacity 388K, committed 512K, reserved 1048576K\n```\n可以看出先是发生了一次minorGC然后又发生了一次fullGC\n### 大对象直接进入老年代\n当对象足够大以至于Eden区域没有连续的足够区域来容纳，对象将直接分配到老年代，我们写段代码来测试\n\n### 长期存活的对象将放入到老年代中\n当年龄超过15岁的对象会被放入到老年代中","slug":"m系列-内存分配和回收策略","published":1,"updated":"2019-06-29T09:00:20.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8c000dkcx1781lp7hl","content":"<h3><span id=\"对象优先在eden区分配\">对象优先在Eden区分配</span></h3>\n<p>对象的内存分配，大方向上就是在堆上进行分配，当Eden区中没有足够的空间分配时，会进行一次minor GC–年轻代GC。<br>\n写一段测试代码来测试下<br>\n参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/29</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class EdenGCDemo &#123;</span><br><span class=\"line\">    private static final int _1MB = 1024 * 1024;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class=\"line\"></span><br><span class=\"line\">        allocation1 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation2 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation3 = new byte[2 * _1MB];</span><br><span class=\"line\">        //发生minor Gc</span><br><span class=\"line\">        allocation4 = new byte[4 * _1MB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 6270K-&gt;705K(9216K), 0.0334506 secs] 6270K-&gt;4801K(19456K), 0.0335107 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def new generation   total 9216K, used 7172K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class=\"line\">  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff250ed0, 0x00000000ff400000)</span><br><span class=\"line\">  from space 1024K,  68% used [0x00000000ff500000, 0x00000000ff5b04e0, 0x00000000ff600000)</span><br><span class=\"line\">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class=\"line\"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class=\"line\"> Metaspace       used 3421K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<p>可以看出发生了一次minor GC，Eden内存由6M变成几乎为0，堆内存由6M变成了5M(?为甚么堆内存会减小，没想明白？)。我们看到form Survivor内存增加了将近1M， 老年代内存增加了4M。说明最后的4M直接被分配到了老年代。<br>\n当老年代所剩的内存区域小于新生代区域并且小于平均每次收集新生代区域的平均值则会发生majorGC/fullGC,我们将上面代码简单修改下即可验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/29</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class EdenGCDemo &#123;</span><br><span class=\"line\">    private static final int _1MB = 1024 * 1024;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class=\"line\"></span><br><span class=\"line\">        allocation1 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation2 = new byte[3 * _1MB];</span><br><span class=\"line\">        //此时发生minorGC</span><br><span class=\"line\">        allocation3 = new byte[2 * _1MB];</span><br><span class=\"line\">        //发生majorGC</span><br><span class=\"line\">        allocation4 = new byte[4 * _1MB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;C:\\Program Files\\Java\\jdk1.8.0_161\\bin\\java&quot; -Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 &quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\lib\\idea_rt.jar=51703:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\rt.jar;D:\\workspace\\personalpj\\spring-cloud-servers\\spring-cloud-moudle\\spring-cloud-moudle-study\\target\\classes&quot; com.spring.cloud.moudle.study.demo.jvm.EdenGCDemo</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 7306K-&gt;840K(9216K)] 7306K-&gt;5968K(19456K), 0.0032098 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 840K-&gt;0K(9216K)] [ParOldGen: 5128K-&gt;5824K(10240K)] 5968K-&gt;5824K(19456K), [Metaspace: 3397K-&gt;3397K(1056768K)], 0.0074300 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 9216K, used 6468K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc510c8,0x00000000ffe00000)</span><br><span class=\"line\">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class=\"line\">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class=\"line\"> ParOldGen       total 10240K, used 5824K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class=\"line\">  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff1b02c8,0x00000000ff600000)</span><br><span class=\"line\"> Metaspace       used 3428K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  class space    used 372K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<p>可以看出先是发生了一次minorGC然后又发生了一次fullGC</p>\n<h3><span id=\"大对象直接进入老年代\">大对象直接进入老年代</span></h3>\n<p>当对象足够大以至于Eden区域没有连续的足够区域来容纳，对象将直接分配到老年代，我们写段代码来测试</p>\n<h3><span id=\"长期存活的对象将放入到老年代中\">长期存活的对象将放入到老年代中</span></h3>\n<p>当年龄超过15岁的对象会被放入到老年代中</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>对象优先在Eden区分配</h3>\n<p>对象的内存分配，大方向上就是在堆上进行分配，当Eden区中没有足够的空间分配时，会进行一次minor GC–年轻代GC。<br>\n写一段测试代码来测试下<br>\n参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/29</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class EdenGCDemo &#123;</span><br><span class=\"line\">    private static final int _1MB = 1024 * 1024;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class=\"line\"></span><br><span class=\"line\">        allocation1 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation2 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation3 = new byte[2 * _1MB];</span><br><span class=\"line\">        //发生minor Gc</span><br><span class=\"line\">        allocation4 = new byte[4 * _1MB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [DefNew: 6270K-&gt;705K(9216K), 0.0334506 secs] 6270K-&gt;4801K(19456K), 0.0335107 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> def new generation   total 9216K, used 7172K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class=\"line\">  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff250ed0, 0x00000000ff400000)</span><br><span class=\"line\">  from space 1024K,  68% used [0x00000000ff500000, 0x00000000ff5b04e0, 0x00000000ff600000)</span><br><span class=\"line\">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class=\"line\"> tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000)</span><br><span class=\"line\"> Metaspace       used 3421K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<p>可以看出发生了一次minor GC，Eden内存由6M变成几乎为0，堆内存由6M变成了5M(?为甚么堆内存会减小，没想明白？)。我们看到form Survivor内存增加了将近1M， 老年代内存增加了4M。说明最后的4M直接被分配到了老年代。<br>\n当老年代所剩的内存区域小于新生代区域并且小于平均每次收集新生代区域的平均值则会发生majorGC/fullGC,我们将上面代码简单修改下即可验证</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/29</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class EdenGCDemo &#123;</span><br><span class=\"line\">    private static final int _1MB = 1024 * 1024;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        byte[] allocation1, allocation2, allocation3, allocation4;</span><br><span class=\"line\"></span><br><span class=\"line\">        allocation1 = new byte[2 * _1MB];</span><br><span class=\"line\">        allocation2 = new byte[3 * _1MB];</span><br><span class=\"line\">        //此时发生minorGC</span><br><span class=\"line\">        allocation3 = new byte[2 * _1MB];</span><br><span class=\"line\">        //发生majorGC</span><br><span class=\"line\">        allocation4 = new byte[4 * _1MB];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;C:\\Program Files\\Java\\jdk1.8.0_161\\bin\\java&quot; -Xmx20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 &quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\lib\\idea_rt.jar=51703:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.1\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_161\\jre\\lib\\rt.jar;D:\\workspace\\personalpj\\spring-cloud-servers\\spring-cloud-moudle\\spring-cloud-moudle-study\\target\\classes&quot; com.spring.cloud.moudle.study.demo.jvm.EdenGCDemo</span><br><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 7306K-&gt;840K(9216K)] 7306K-&gt;5968K(19456K), 0.0032098 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class=\"line\">[Full GC (Ergonomics) [PSYoungGen: 840K-&gt;0K(9216K)] [ParOldGen: 5128K-&gt;5824K(10240K)] 5968K-&gt;5824K(19456K), [Metaspace: 3397K-&gt;3397K(1056768K)], 0.0074300 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class=\"line\">Heap</span><br><span class=\"line\"> PSYoungGen      total 9216K, used 6468K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc510c8,0x00000000ffe00000)</span><br><span class=\"line\">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class=\"line\">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class=\"line\"> ParOldGen       total 10240K, used 5824K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class=\"line\">  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff1b02c8,0x00000000ff600000)</span><br><span class=\"line\"> Metaspace       used 3428K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class=\"line\">  class space    used 372K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>\n<p>可以看出先是发生了一次minorGC然后又发生了一次fullGC</p>\n<h3>大对象直接进入老年代</h3>\n<p>当对象足够大以至于Eden区域没有连续的足够区域来容纳，对象将直接分配到老年代，我们写段代码来测试</p>\n<h3>长期存活的对象将放入到老年代中</h3>\n<p>当年龄超过15岁的对象会被放入到老年代中</p>\n"},{"title":"jvm系列- 垃圾收集器","catalog":true,"author":"wangmj","date":"2018-10-21T08:56:00.000Z","subtitle":null,"header-img":null,"_content":"### 垃圾收集器\n#### \tserial收集器\nserial收集器是最原始的收集器，其是一个单线程收集器，当其垃圾回收时会\"stop the world\"，暂停所有程序，但是其在CPU核数较少的时候会比较高效，因为单线程减少了线程切换的开销。\n看图明白其原理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129161914822.png)\n#### ParNew 收集器\nParNew收集器实际上是serial收集器的多线程版，其主要是在server模式下的新生代收集器，因为只有ParNew和serial收集器可以和CMS收集器共同使用。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129162429994.png)\n#### Parallel Scavenge收集器\nParallel Scavenge收集器是一个新生代收集器，也是一个多线程收集器，看起来和ParNew收集器一样，但是他的关注点不一样\n其主要关注的是可控制的吞吐量，被称为吞吐量优先收集器，可以设置在一定时间内完成垃圾回收，但是不是设置的时间越小越好，当时间越小则会造成收集频率增加，新生代内存动态减少等后果，jdk1.8默认使用的是这种收集器\n#### Serial old 收集器\n是一种老年代的收集器，是单线程收集器，使用标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129163541280.png)\n#### parallel old收集器\nparallel old收集器是parallel scavenge老年代版本，是多线程线程收集器，采用的是标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129171759546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### CMS收集器\n是一种获取最短时间停顿的收集器，主要是“标记-清除”算法，主要由四个步骤\n- 初始标记\n- 并发标记\n- 重新标记\n- 并发清除\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201901291722033.png)\n可以看出，初始标记和重复标记需要stop the world，而并发标记和并发清除不需要停顿\n\n#### G1收集器\nG1收集器是jdk1,7才开始投入使用的收集器，其和CMS收集器主要区别是可以精准预测停顿时间在什么时间段，其主要实现是讲堆分成若干个Region区域，对每个区域进行分区收集\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129172542722.png)\n### 垃圾收集器参数总结\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012917262952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012917264981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n","source":"_posts/jvm系列-垃圾收集器.md","raw":"title: jvm系列- 垃圾收集器\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-10-21 16:56:00\nsubtitle:\nheader-img:\n---\n### 垃圾收集器\n#### \tserial收集器\nserial收集器是最原始的收集器，其是一个单线程收集器，当其垃圾回收时会\"stop the world\"，暂停所有程序，但是其在CPU核数较少的时候会比较高效，因为单线程减少了线程切换的开销。\n看图明白其原理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129161914822.png)\n#### ParNew 收集器\nParNew收集器实际上是serial收集器的多线程版，其主要是在server模式下的新生代收集器，因为只有ParNew和serial收集器可以和CMS收集器共同使用。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129162429994.png)\n#### Parallel Scavenge收集器\nParallel Scavenge收集器是一个新生代收集器，也是一个多线程收集器，看起来和ParNew收集器一样，但是他的关注点不一样\n其主要关注的是可控制的吞吐量，被称为吞吐量优先收集器，可以设置在一定时间内完成垃圾回收，但是不是设置的时间越小越好，当时间越小则会造成收集频率增加，新生代内存动态减少等后果，jdk1.8默认使用的是这种收集器\n#### Serial old 收集器\n是一种老年代的收集器，是单线程收集器，使用标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129163541280.png)\n#### parallel old收集器\nparallel old收集器是parallel scavenge老年代版本，是多线程线程收集器，采用的是标记-整理算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129171759546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### CMS收集器\n是一种获取最短时间停顿的收集器，主要是“标记-清除”算法，主要由四个步骤\n- 初始标记\n- 并发标记\n- 重新标记\n- 并发清除\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201901291722033.png)\n可以看出，初始标记和重复标记需要stop the world，而并发标记和并发清除不需要停顿\n\n#### G1收集器\nG1收集器是jdk1,7才开始投入使用的收集器，其和CMS收集器主要区别是可以精准预测停顿时间在什么时间段，其主要实现是讲堆分成若干个Region区域，对每个区域进行分区收集\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129172542722.png)\n### 垃圾收集器参数总结\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012917262952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012917264981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n","slug":"jvm系列-垃圾收集器","published":1,"updated":"2019-06-29T08:57:07.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8d000ekcx14fh2cgas","content":"<h3><span id=\"垃圾收集器\">垃圾收集器</span></h3>\n<h4><span id=\"serial收集器\">serial收集器</span></h4>\n<p>serial收集器是最原始的收集器，其是一个单线程收集器，当其垃圾回收时会&quot;stop the world&quot;，暂停所有程序，但是其在CPU核数较少的时候会比较高效，因为单线程减少了线程切换的开销。<br>\n看图明白其原理<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129161914822.png\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"parnew-收集器\">ParNew 收集器</span></h4>\n<p>ParNew收集器实际上是serial收集器的多线程版，其主要是在server模式下的新生代收集器，因为只有ParNew和serial收集器可以和CMS收集器共同使用。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129162429994.png\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"parallel-scavenge收集器\">Parallel Scavenge收集器</span></h4>\n<p>Parallel Scavenge收集器是一个新生代收集器，也是一个多线程收集器，看起来和ParNew收集器一样，但是他的关注点不一样<br>\n其主要关注的是可控制的吞吐量，被称为吞吐量优先收集器，可以设置在一定时间内完成垃圾回收，但是不是设置的时间越小越好，当时间越小则会造成收集频率增加，新生代内存动态减少等后果，jdk1.8默认使用的是这种收集器</p>\n<h4><span id=\"serial-old-收集器\">Serial old 收集器</span></h4>\n<p>是一种老年代的收集器，是单线程收集器，使用标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129163541280.png\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"parallel-old收集器\">parallel old收集器</span></h4>\n<p>parallel old收集器是parallel scavenge老年代版本，是多线程线程收集器，采用的是标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129171759546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"cms收集器\">CMS收集器</span></h4>\n<p>是一种获取最短时间停顿的收集器，主要是“标记-清除”算法，主要由四个步骤</p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除<br>\n<img src=\"https://img-blog.csdnimg.cn/201901291722033.png\" alt=\"在这里插入图片描述\"><br>\n可以看出，初始标记和重复标记需要stop the world，而并发标记和并发清除不需要停顿</li>\n</ul>\n<h4><span id=\"g1收集器\">G1收集器</span></h4>\n<p>G1收集器是jdk1,7才开始投入使用的收集器，其和CMS收集器主要区别是可以精准预测停顿时间在什么时间段，其主要实现是讲堆分成若干个Region区域，对每个区域进行分区收集<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129172542722.png\" alt=\"在这里插入图片描述\"></p>\n<h3><span id=\"垃圾收集器参数总结\">垃圾收集器参数总结</span></h3>\n<p><img src=\"https://img-blog.csdnimg.cn/2019012917262952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/2019012917264981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>垃圾收集器</h3>\n<h4>serial收集器</h4>\n<p>serial收集器是最原始的收集器，其是一个单线程收集器，当其垃圾回收时会&quot;stop the world&quot;，暂停所有程序，但是其在CPU核数较少的时候会比较高效，因为单线程减少了线程切换的开销。<br>\n看图明白其原理<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129161914822.png\" alt=\"在这里插入图片描述\"></p>\n<h4>ParNew 收集器</h4>\n<p>ParNew收集器实际上是serial收集器的多线程版，其主要是在server模式下的新生代收集器，因为只有ParNew和serial收集器可以和CMS收集器共同使用。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129162429994.png\" alt=\"在这里插入图片描述\"></p>\n<h4>Parallel Scavenge收集器</h4>\n<p>Parallel Scavenge收集器是一个新生代收集器，也是一个多线程收集器，看起来和ParNew收集器一样，但是他的关注点不一样<br>\n其主要关注的是可控制的吞吐量，被称为吞吐量优先收集器，可以设置在一定时间内完成垃圾回收，但是不是设置的时间越小越好，当时间越小则会造成收集频率增加，新生代内存动态减少等后果，jdk1.8默认使用的是这种收集器</p>\n<h4>Serial old 收集器</h4>\n<p>是一种老年代的收集器，是单线程收集器，使用标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129163541280.png\" alt=\"在这里插入图片描述\"></p>\n<h4>parallel old收集器</h4>\n<p>parallel old收集器是parallel scavenge老年代版本，是多线程线程收集器，采用的是标记-整理算法<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129171759546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4>CMS收集器</h4>\n<p>是一种获取最短时间停顿的收集器，主要是“标记-清除”算法，主要由四个步骤</p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除<br>\n<img src=\"https://img-blog.csdnimg.cn/201901291722033.png\" alt=\"在这里插入图片描述\"><br>\n可以看出，初始标记和重复标记需要stop the world，而并发标记和并发清除不需要停顿</li>\n</ul>\n<h4>G1收集器</h4>\n<p>G1收集器是jdk1,7才开始投入使用的收集器，其和CMS收集器主要区别是可以精准预测停顿时间在什么时间段，其主要实现是讲堆分成若干个Region区域，对每个区域进行分区收集<br>\n<img src=\"https://img-blog.csdnimg.cn/20190129172542722.png\" alt=\"在这里插入图片描述\"></p>\n<h3>垃圾收集器参数总结</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/2019012917262952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/2019012917264981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"java基础之集合框架--HashMap深入理解及应用","catalog":true,"author":"wangmj","date":"2017-11-02T08:30:00.000Z","subtitle":null,"header-img":null,"_content":"# java基础之集合框架--HashMap深入理解及应用\n\n接着上一篇写，在分析之前，先想想几个问题，方便后面理解\n1.HashMap的底层结构是什么，画出来；\n2.再用HashMap的时候会考虑他的容量吗？它的默认容量是多少，加如超过了你初始化的容量会发生什么?\n3.HashMap key是否可以为null；\n4.自己实现一个简单的HashMap（HashMap的实现原理）\n\n### HashMap底层结构\n![这里写图片描述](http://img.blog.csdn.net/20171109152256888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n上图即为hashMap的底层存储结构图，可以看出，其实就是一个类似数组+链表来存储的，数组默认长度为16；那么数组中如何来存储key,value对象呢？来看下hashMap的源码，我直接拿jdk 1.8的源码来\n```\n  /**\n     * The table, initialized on first use, and resized as\n     * necessary. When allocated, length is always a power of two.\n     * (We also tolerate length zero in some operations to allow\n     * bootstrapping mechanics that are currently not needed.)\n     */\n     //存放key value值得数组\n    transient Node<K,V>[] table;\n\n  /**\n     * Basic hash bin node, used for most entries.  (See below for\n     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n     */\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n\n\t\t//存放key Value及下个元素的标识next\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n其实存放key,value就放在这个Node里面，Node会在第一次初始化赋值，它为一个静态的内部类，实现了Map.Entry内部接口；\n当map.put元素的时候，hashMap会根据hashcode值来计算出一个index，来存放此对象；若下一个对象算出的index值与第一个index值相同，则将原始的next标记为下一个对象，这样就形成了单项有序的链表；\n再来看一下HashMap的put怎么实现的：\n\n```\n    /**\n     * Implements Map.put and related methods\n     *\n     * @param hash key的hash值\n     * @param key \n     * @param value the value to put\n     * @param onlyIfAbsent 判断是否为重复的key，若true，则改变value值，默认为false\n     * @param evict 是否为初始化map，默认true\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        //赋值tab，判断table是否为空\n        if ((tab = table) == null || (n = tab.length) == 0)\n        //若为空，则赋值n为0\n            n = (tab = resize()).length;\n            //(n - 1) & hash计算index，若tab空，则新赋值,并将next设为null；\n        if ((p = tab[i = (n - 1) & hash]) == null)\n        //为此index赋值\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//若Index处有值，则将此处值得next赋给新值\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            //若key已经存在，则将此key处的值替换\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)//计算大于威胁容量\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n上面代码我加了写注释，简单点说，就是put新值的时候，先存储起来，放在一个Node里面，index是0，在次put的时候，先计算index值，**(n - 1) & hash**；若index相同，则将值放在next里，若不相同，则将值放在新的index里；\n  get值得时候同理，先计算index值，然后再根据index值来看有没有这个key，没有在看next里有没有；\n\n```\nif (++size > threshold)//计算大于威胁容量\n            resize();\n```\n下面说下这段代码的意义，即我们讨论的map容量与扩容问题。threshold参数的意义为威胁容量，当我们的size大于威胁容量的时候，map就会扩容处理；当默认容量为16时，威胁容量为12，若map得size大于12时，则会进入risize方法，并对容量及威胁容量都进行双倍扩容处理；关键代码\n\n```\nif (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //newCap双倍扩容\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // 双倍扩容\n        }\n```\nHashMap暂时就分析到这，上面几个问题的答案也就都出来了，还有好多细节方面的知识，包括怎么计算算出index值中的参数；值得我们深入研究下并借鉴。","source":"_posts/titledjava基础之集合框架-HashMap深入理解及应用.md","raw":"title: java基础之集合框架--HashMap深入理解及应用\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2017-11-02 16:30:00\nsubtitle:\nheader-img:\n---\n# java基础之集合框架--HashMap深入理解及应用\n\n接着上一篇写，在分析之前，先想想几个问题，方便后面理解\n1.HashMap的底层结构是什么，画出来；\n2.再用HashMap的时候会考虑他的容量吗？它的默认容量是多少，加如超过了你初始化的容量会发生什么?\n3.HashMap key是否可以为null；\n4.自己实现一个简单的HashMap（HashMap的实现原理）\n\n### HashMap底层结构\n![这里写图片描述](http://img.blog.csdn.net/20171109152256888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n上图即为hashMap的底层存储结构图，可以看出，其实就是一个类似数组+链表来存储的，数组默认长度为16；那么数组中如何来存储key,value对象呢？来看下hashMap的源码，我直接拿jdk 1.8的源码来\n```\n  /**\n     * The table, initialized on first use, and resized as\n     * necessary. When allocated, length is always a power of two.\n     * (We also tolerate length zero in some operations to allow\n     * bootstrapping mechanics that are currently not needed.)\n     */\n     //存放key value值得数组\n    transient Node<K,V>[] table;\n\n  /**\n     * Basic hash bin node, used for most entries.  (See below for\n     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)\n     */\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n\n\t\t//存放key Value及下个元素的标识next\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n其实存放key,value就放在这个Node里面，Node会在第一次初始化赋值，它为一个静态的内部类，实现了Map.Entry内部接口；\n当map.put元素的时候，hashMap会根据hashcode值来计算出一个index，来存放此对象；若下一个对象算出的index值与第一个index值相同，则将原始的next标记为下一个对象，这样就形成了单项有序的链表；\n再来看一下HashMap的put怎么实现的：\n\n```\n    /**\n     * Implements Map.put and related methods\n     *\n     * @param hash key的hash值\n     * @param key \n     * @param value the value to put\n     * @param onlyIfAbsent 判断是否为重复的key，若true，则改变value值，默认为false\n     * @param evict 是否为初始化map，默认true\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        //赋值tab，判断table是否为空\n        if ((tab = table) == null || (n = tab.length) == 0)\n        //若为空，则赋值n为0\n            n = (tab = resize()).length;\n            //(n - 1) & hash计算index，若tab空，则新赋值,并将next设为null；\n        if ((p = tab[i = (n - 1) & hash]) == null)\n        //为此index赋值\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//若Index处有值，则将此处值得next赋给新值\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            //若key已经存在，则将此key处的值替换\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)//计算大于威胁容量\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n上面代码我加了写注释，简单点说，就是put新值的时候，先存储起来，放在一个Node里面，index是0，在次put的时候，先计算index值，**(n - 1) & hash**；若index相同，则将值放在next里，若不相同，则将值放在新的index里；\n  get值得时候同理，先计算index值，然后再根据index值来看有没有这个key，没有在看next里有没有；\n\n```\nif (++size > threshold)//计算大于威胁容量\n            resize();\n```\n下面说下这段代码的意义，即我们讨论的map容量与扩容问题。threshold参数的意义为威胁容量，当我们的size大于威胁容量的时候，map就会扩容处理；当默认容量为16时，威胁容量为12，若map得size大于12时，则会进入risize方法，并对容量及威胁容量都进行双倍扩容处理；关键代码\n\n```\nif (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //newCap双倍扩容\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // 双倍扩容\n        }\n```\nHashMap暂时就分析到这，上面几个问题的答案也就都出来了，还有好多细节方面的知识，包括怎么计算算出index值中的参数；值得我们深入研究下并借鉴。","slug":"titledjava基础之集合框架-HashMap深入理解及应用","published":1,"updated":"2019-06-29T08:32:56.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8e000gkcx1di754gkr","content":"<h1><span id=\"java基础之集合框架hashmap深入理解及应用\">java基础之集合框架–HashMap深入理解及应用</span></h1>\n<p>接着上一篇写，在分析之前，先想想几个问题，方便后面理解<br>\n1.HashMap的底层结构是什么，画出来；<br>\n2.再用HashMap的时候会考虑他的容量吗？它的默认容量是多少，加如超过了你初始化的容量会发生什么?<br>\n3.HashMap key是否可以为null；<br>\n4.自己实现一个简单的HashMap（HashMap的实现原理）</p>\n<h3><span id=\"hashmap底层结构\">HashMap底层结构</span></h3>\n<p><img src=\"http://img.blog.csdn.net/20171109152256888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n上图即为hashMap的底层存储结构图，可以看出，其实就是一个类似数组+链表来存储的，数组默认长度为16；那么数组中如何来存储key,value对象呢？来看下hashMap的源码，我直接拿jdk 1.8的源码来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * The table, initialized on first use, and resized as</span><br><span class=\"line\">   * necessary. When allocated, length is always a power of two.</span><br><span class=\"line\">   * (We also tolerate length zero in some operations to allow</span><br><span class=\"line\">   * bootstrapping mechanics that are currently not needed.)</span><br><span class=\"line\">   */</span><br><span class=\"line\">   //存放key value值得数组</span><br><span class=\"line\">  transient Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">   * Basic hash bin node, used for most entries.  (See below for</span><br><span class=\"line\">   * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class=\"line\">   */</span><br><span class=\"line\">  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">      final int hash;</span><br><span class=\"line\">      final K key;</span><br><span class=\"line\">      V value;</span><br><span class=\"line\">      Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">//存放key Value及下个元素的标识next</span><br><span class=\"line\">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">          this.hash = hash;</span><br><span class=\"line\">          this.key = key;</span><br><span class=\"line\">          this.value = value;</span><br><span class=\"line\">          this.next = next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final K getKey()        &#123; return key; &#125;</span><br><span class=\"line\">      public final V getValue()      &#123; return value; &#125;</span><br><span class=\"line\">      public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final int hashCode() &#123;</span><br><span class=\"line\">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final V setValue(V newValue) &#123;</span><br><span class=\"line\">          V oldValue = value;</span><br><span class=\"line\">          value = newValue;</span><br><span class=\"line\">          return oldValue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final boolean equals(Object o) &#123;</span><br><span class=\"line\">          if (o == this)</span><br><span class=\"line\">              return true;</span><br><span class=\"line\">          if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                  Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                  return true;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实存放key,value就放在这个Node里面，Node会在第一次初始化赋值，它为一个静态的内部类，实现了Map.Entry内部接口；<br>\n当map.put元素的时候，hashMap会根据hashcode值来计算出一个index，来存放此对象；若下一个对象算出的index值与第一个index值相同，则将原始的next标记为下一个对象，这样就形成了单项有序的链表；<br>\n再来看一下HashMap的put怎么实现的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Implements Map.put and related methods</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param hash key的hash值</span><br><span class=\"line\"> * @param key </span><br><span class=\"line\"> * @param value the value to put</span><br><span class=\"line\"> * @param onlyIfAbsent 判断是否为重复的key，若true，则改变value值，默认为false</span><br><span class=\"line\"> * @param evict 是否为初始化map，默认true</span><br><span class=\"line\"> * @return previous value, or null if none</span><br><span class=\"line\"> */</span><br><span class=\"line\">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class=\"line\">               boolean evict) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class=\"line\">    //赋值tab，判断table是否为空</span><br><span class=\"line\">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class=\"line\">    //若为空，则赋值n为0</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">        //(n - 1) &amp; hash计算index，若tab空，则新赋值,并将next设为null；</span><br><span class=\"line\">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class=\"line\">    //为此index赋值</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, null);</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        if (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        else if (p instanceof TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class=\"line\">        else &#123;//若Index处有值，则将此处值得next赋给新值</span><br><span class=\"line\">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class=\"line\">                if ((e = p.next) == null) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, null);</span><br><span class=\"line\">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //若key已经存在，则将此key处的值替换</span><br><span class=\"line\">        if (e != null) &#123; // existing mapping for key</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            if (!onlyIfAbsent || oldValue == null)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            return oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    if (++size &gt; threshold)//计算大于威胁容量</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码我加了写注释，简单点说，就是put新值的时候，先存储起来，放在一个Node里面，index是0，在次put的时候，先计算index值，<strong>(n - 1) &amp; hash</strong>；若index相同，则将值放在next里，若不相同，则将值放在新的index里；<br>\nget值得时候同理，先计算index值，然后再根据index值来看有没有这个key，没有在看next里有没有；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (++size &gt; threshold)//计算大于威胁容量</span><br><span class=\"line\">            resize();</span><br></pre></td></tr></table></figure>\n<p>下面说下这段代码的意义，即我们讨论的map容量与扩容问题。threshold参数的意义为威胁容量，当我们的size大于威胁容量的时候，map就会扩容处理；当默认容量为16时，威胁容量为12，若map得size大于12时，则会进入risize方法，并对容量及威胁容量都进行双倍扩容处理；关键代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                return oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //newCap双倍扩容</span><br><span class=\"line\">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; 1; // 双倍扩容</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>HashMap暂时就分析到这，上面几个问题的答案也就都出来了，还有好多细节方面的知识，包括怎么计算算出index值中的参数；值得我们深入研究下并借鉴。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>java基础之集合框架–HashMap深入理解及应用</h1>\n<p>接着上一篇写，在分析之前，先想想几个问题，方便后面理解<br>\n1.HashMap的底层结构是什么，画出来；<br>\n2.再用HashMap的时候会考虑他的容量吗？它的默认容量是多少，加如超过了你初始化的容量会发生什么?<br>\n3.HashMap key是否可以为null；<br>\n4.自己实现一个简单的HashMap（HashMap的实现原理）</p>\n<h3>HashMap底层结构</h3>\n<p><img src=\"http://img.blog.csdn.net/20171109152256888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>\n上图即为hashMap的底层存储结构图，可以看出，其实就是一个类似数组+链表来存储的，数组默认长度为16；那么数组中如何来存储key,value对象呢？来看下hashMap的源码，我直接拿jdk 1.8的源码来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">   * The table, initialized on first use, and resized as</span><br><span class=\"line\">   * necessary. When allocated, length is always a power of two.</span><br><span class=\"line\">   * (We also tolerate length zero in some operations to allow</span><br><span class=\"line\">   * bootstrapping mechanics that are currently not needed.)</span><br><span class=\"line\">   */</span><br><span class=\"line\">   //存放key value值得数组</span><br><span class=\"line\">  transient Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">   * Basic hash bin node, used for most entries.  (See below for</span><br><span class=\"line\">   * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class=\"line\">   */</span><br><span class=\"line\">  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">      final int hash;</span><br><span class=\"line\">      final K key;</span><br><span class=\"line\">      V value;</span><br><span class=\"line\">      Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">//存放key Value及下个元素的标识next</span><br><span class=\"line\">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">          this.hash = hash;</span><br><span class=\"line\">          this.key = key;</span><br><span class=\"line\">          this.value = value;</span><br><span class=\"line\">          this.next = next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final K getKey()        &#123; return key; &#125;</span><br><span class=\"line\">      public final V getValue()      &#123; return value; &#125;</span><br><span class=\"line\">      public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final int hashCode() &#123;</span><br><span class=\"line\">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final V setValue(V newValue) &#123;</span><br><span class=\"line\">          V oldValue = value;</span><br><span class=\"line\">          value = newValue;</span><br><span class=\"line\">          return oldValue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final boolean equals(Object o) &#123;</span><br><span class=\"line\">          if (o == this)</span><br><span class=\"line\">              return true;</span><br><span class=\"line\">          if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                  Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                  return true;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return false;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实存放key,value就放在这个Node里面，Node会在第一次初始化赋值，它为一个静态的内部类，实现了Map.Entry内部接口；<br>\n当map.put元素的时候，hashMap会根据hashcode值来计算出一个index，来存放此对象；若下一个对象算出的index值与第一个index值相同，则将原始的next标记为下一个对象，这样就形成了单项有序的链表；<br>\n再来看一下HashMap的put怎么实现的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Implements Map.put and related methods</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param hash key的hash值</span><br><span class=\"line\"> * @param key </span><br><span class=\"line\"> * @param value the value to put</span><br><span class=\"line\"> * @param onlyIfAbsent 判断是否为重复的key，若true，则改变value值，默认为false</span><br><span class=\"line\"> * @param evict 是否为初始化map，默认true</span><br><span class=\"line\"> * @return previous value, or null if none</span><br><span class=\"line\"> */</span><br><span class=\"line\">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class=\"line\">               boolean evict) &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class=\"line\">    //赋值tab，判断table是否为空</span><br><span class=\"line\">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class=\"line\">    //若为空，则赋值n为0</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">        //(n - 1) &amp; hash计算index，若tab空，则新赋值,并将next设为null；</span><br><span class=\"line\">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class=\"line\">    //为此index赋值</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, null);</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        if (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        else if (p instanceof TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class=\"line\">        else &#123;//若Index处有值，则将此处值得next赋给新值</span><br><span class=\"line\">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class=\"line\">                if ((e = p.next) == null) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, null);</span><br><span class=\"line\">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //若key已经存在，则将此key处的值替换</span><br><span class=\"line\">        if (e != null) &#123; // existing mapping for key</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            if (!onlyIfAbsent || oldValue == null)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            return oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    if (++size &gt; threshold)//计算大于威胁容量</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码我加了写注释，简单点说，就是put新值的时候，先存储起来，放在一个Node里面，index是0，在次put的时候，先计算index值，<strong>(n - 1) &amp; hash</strong>；若index相同，则将值放在next里，若不相同，则将值放在新的index里；<br>\nget值得时候同理，先计算index值，然后再根据index值来看有没有这个key，没有在看next里有没有；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (++size &gt; threshold)//计算大于威胁容量</span><br><span class=\"line\">            resize();</span><br></pre></td></tr></table></figure>\n<p>下面说下这段代码的意义，即我们讨论的map容量与扩容问题。threshold参数的意义为威胁容量，当我们的size大于威胁容量的时候，map就会扩容处理；当默认容量为16时，威胁容量为12，若map得size大于12时，则会进入risize方法，并对容量及威胁容量都进行双倍扩容处理；关键代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                return oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //newCap双倍扩容</span><br><span class=\"line\">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; 1; // 双倍扩容</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>HashMap暂时就分析到这，上面几个问题的答案也就都出来了，还有好多细节方面的知识，包括怎么计算算出index值中的参数；值得我们深入研究下并借鉴。</p>\n"},{"title":"jvm系列--虚拟机性能监控工具","catalog":true,"author":"wangmj","date":"2018-11-03T08:58:00.000Z","subtitle":null,"header-img":null,"_content":"### JDK命令行工具\n#### jps\njps可以列出正在运行的虚拟机内存，是一款简单单一的工具\n命令 jps [options] [hostid]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220130302.png)\n#### jstat\n虚拟机统计信息监视工具，是运行期地位虚拟机性能问题的首选工具，他可以显示本地或者远程的类加载、内存、垃圾收集等信息。\n命令：jstat [option vmid [interval[s|ms] {count}]]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220509169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n运行 jstat -gc pid 250 20表示每250ms打印一次gc信息，共输出20次\n常用的还有jstat -gcutil\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220554689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### jmap\njmap 用于生成堆存储快照信息(一般为heapdump和dump文件)\n命令：jmap [options] pid\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130221316217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### jstack\njava堆栈跟踪工具，主要用于生成当前线程快照信息，\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130221521939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n### jdk可视化工具\n#### jConsole\n是一款jdk自带的分析jvm性能的插件，启动程序在jdk/bin目录下\n#### VisualVM\n是一款非常优秀的jdk自带jvm性能插件","source":"_posts/jvm系列-虚拟机性能监控工具.md","raw":"title: jvm系列--虚拟机性能监控工具\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-11-03 16:58:00\nsubtitle:\nheader-img:\n---\n### JDK命令行工具\n#### jps\njps可以列出正在运行的虚拟机内存，是一款简单单一的工具\n命令 jps [options] [hostid]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220130302.png)\n#### jstat\n虚拟机统计信息监视工具，是运行期地位虚拟机性能问题的首选工具，他可以显示本地或者远程的类加载、内存、垃圾收集等信息。\n命令：jstat [option vmid [interval[s|ms] {count}]]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220509169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n运行 jstat -gc pid 250 20表示每250ms打印一次gc信息，共输出20次\n常用的还有jstat -gcutil\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130220554689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### jmap\njmap 用于生成堆存储快照信息(一般为heapdump和dump文件)\n命令：jmap [options] pid\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130221316217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n#### jstack\njava堆栈跟踪工具，主要用于生成当前线程快照信息，\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190130221521939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n### jdk可视化工具\n#### jConsole\n是一款jdk自带的分析jvm性能的插件，启动程序在jdk/bin目录下\n#### VisualVM\n是一款非常优秀的jdk自带jvm性能插件","slug":"jvm系列-虚拟机性能监控工具","published":1,"updated":"2019-06-29T08:59:04.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8f000hkcx119xpfudc","content":"<h3><span id=\"jdk命令行工具\">JDK命令行工具</span></h3>\n<h4><span id=\"jps\">jps</span></h4>\n<p>jps可以列出正在运行的虚拟机内存，是一款简单单一的工具<br>\n命令 jps [options] [hostid]<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220130302.png\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"jstat\">jstat</span></h4>\n<p>虚拟机统计信息监视工具，是运行期地位虚拟机性能问题的首选工具，他可以显示本地或者远程的类加载、内存、垃圾收集等信息。<br>\n命令：jstat [option vmid [interval[s|ms] {count}]]<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220509169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n运行 jstat -gc pid 250 20表示每250ms打印一次gc信息，共输出20次<br>\n常用的还有jstat -gcutil<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220554689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"jmap\">jmap</span></h4>\n<p>jmap 用于生成堆存储快照信息(一般为heapdump和dump文件)<br>\n命令：jmap [options] pid<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130221316217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4><span id=\"jstack\">jstack</span></h4>\n<p>java堆栈跟踪工具，主要用于生成当前线程快照信息，<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130221521939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3><span id=\"jdk可视化工具\">jdk可视化工具</span></h3>\n<h4><span id=\"jconsole\">jConsole</span></h4>\n<p>是一款jdk自带的分析jvm性能的插件，启动程序在jdk/bin目录下</p>\n<h4><span id=\"visualvm\">VisualVM</span></h4>\n<p>是一款非常优秀的jdk自带jvm性能插件</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>JDK命令行工具</h3>\n<h4>jps</h4>\n<p>jps可以列出正在运行的虚拟机内存，是一款简单单一的工具<br>\n命令 jps [options] [hostid]<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220130302.png\" alt=\"在这里插入图片描述\"></p>\n<h4>jstat</h4>\n<p>虚拟机统计信息监视工具，是运行期地位虚拟机性能问题的首选工具，他可以显示本地或者远程的类加载、内存、垃圾收集等信息。<br>\n命令：jstat [option vmid [interval[s|ms] {count}]]<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220509169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n运行 jstat -gc pid 250 20表示每250ms打印一次gc信息，共输出20次<br>\n常用的还有jstat -gcutil<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130220554689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4>jmap</h4>\n<p>jmap 用于生成堆存储快照信息(一般为heapdump和dump文件)<br>\n命令：jmap [options] pid<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130221316217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4>jstack</h4>\n<p>java堆栈跟踪工具，主要用于生成当前线程快照信息，<br>\n<img src=\"https://img-blog.csdnimg.cn/20190130221521939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3>jdk可视化工具</h3>\n<h4>jConsole</h4>\n<p>是一款jdk自带的分析jvm性能的插件，启动程序在jdk/bin目录下</p>\n<h4>VisualVM</h4>\n<p>是一款非常优秀的jdk自带jvm性能插件</p>\n"},{"title":"java concurrent包下的锁","catalog":true,"author":"wangmj","date":"2018-07-29T08:52:00.000Z","subtitle":null,"header-img":null,"_content":"### concurrent包下锁的种类\n- 接口：Lock、ReadWriteLock、Condition\n- 实现类：ReentrantLock、ReentrantReadWriteLock、StampedLock\n- 抽象类：AbstractQueuedSychronizer\n\n简单梳理下锁的关系ReentrantLock实现了Lock接口，并内部实现了AQS同步器；ReentrantReadWriteLock实现了ReadWriteLock接口，并有内部类实现类AQS同步器，可以看出无论上面两种锁实现的关键都是AQS同步器，足以看出想要深入理解锁，必须先掌握AQS同步器，可以查看我的上一篇介绍AQS的博客【[同步队列-AbstractQueuedSyncronizer](https://blog.csdn.net/wmj765/article/details/86539873)】下面将逐一介绍并写demo来理解锁的使用方法。\n\n#### ReentrantLock可重入锁分析及使用\n- volatile int state 状态值，很重要的一个参数，来标识同步状态，可以先将其理解为当前已经获取锁的次数(不准确，为入门者方便理解，后面会具体分析)。\n- sync extends AQS 内部类，继承同步器，需要自己重写tryAcquire()、tryRelease()或者tryAcquireShared()、tryReleaseShared方法；一个是独占锁的实现，一个是可共享的实现\n\n##### 共享锁与独占锁\n\n独占锁的实现上篇博客写了个例子，这里在简单总结下，独占就相当于同时只有一个线程可以获取到锁，其他线程则阻塞在队列中，此时只需在获取锁的时候判断state值是否为0，若为0，则cas自旋将1赋值给state，若为1，则将当前线程放入到队列中，内部结构为双向链表。\n共享锁即同时可以有多个线程获取到锁（CountDownLatch），思路其实和独占锁大体相同，只不过state值将不是以1位分界，下面我自己实现了一个简单的共享锁\n\n```\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/**\n * 自定义共享锁，继承AQS，重写tryAcquireShared/tryReleaseShared\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class CountDownLock {\n    private final class sync extends AbstractQueuedSynchronizer {\n        //自旋CAS将state设置成剩余可进入线程数\n        @Override\n        protected int tryAcquireShared(int reduce) {\n            for (; ; ) {\n                //当前状态值\n                int current = getState();\n                //剩余可进入的线程\n                int rest = current - reduce;\n                //当rest<0将线程任务放入队列等待\n                if (rest < 0 || compareAndSetState(current, rest)) {\n                    return rest;\n                }\n            }\n        }\n\n\n        @Override\n        protected boolean tryReleaseShared(int increment) {\n            for (; ; ) {\n                int current = getState();\n                int newCount = current + increment;\n                if (newCount > 2)\n                    throw new IllegalArgumentException();\n                if (compareAndSetState(current, newCount)) {\n                    return true;\n                }\n            }\n        }\n\n        sync(int count) {\n            if (count < 0)\n                throw new IllegalMonitorStateException();\n            setState(count);\n        }\n    }\n\n    private final sync sync = new sync(2);\n\n    public void lock() {\n        sync.acquireShared(1);\n    }\n\n    public void unLock() {\n        sync.releaseShared(1);\n    }\n}\n```\n上面代码固定实现了可以2个线程共享的功能，继续写一段测试代码来验证是否成功\n\n```\n/**\n * 共享锁测试类 结果应为两个线程同时获取到锁，然后等待1S，即线程成对出现\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class CountDownLockTest {\n\n    static class task implements Runnable {\n        CountDownLock lock = new CountDownLock();\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                Thread.sleep(1000);\n                System.out.println(\"currentThread\" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unLock();\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        task task = new task();\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(task);\n            thread.start();\n        }\n    }\n}\n```\n结果是线程成对出现，并间隔一秒，即同时可以有两个线程来获取到锁\n\n##### 公平锁与非公平锁\n公平锁与非公平锁的主要区别是公平锁会完全按照先入先出的顺序来执行等待队列中的线程，而非公平锁则在获取锁的时候会先尝试当前线程获取到锁，若当前线程获取锁失败，则加入等待队列后和公平锁没有区别，下面我写了个简单的例子来看公平锁和非公平锁\n\n```\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 继承ReentrantLock，重写getQueuedThreads,将当前队列反转成正序\n *\n * @author wangmj\n * @since 2019/1/19\n */\npublic class RentrantLockDemo extends ReentrantLock {\n\n    public RentrantLockDemo(boolean fair) {\n        super(fair);\n    }\n\n    @Override\n    public Collection<Thread> getQueuedThreads() {\n        List list = new ArrayList(super.getQueuedThreads());\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n继续写一个测试类，来测试公平锁与非公平锁\n\n```\n/**\n * 测试公平锁与非公平锁的区别\n *\n * @author wangmj\n * @since 2019/1/19\n */\npublic class ReentrantLockTest {\n    private static RentrantLockDemo fairLock = new RentrantLockDemo(true);\n    private static RentrantLockDemo unfairLock = new RentrantLockDemo(false);\n\n\n    static class Task implements Runnable {\n        private RentrantLockDemo lock;\n\n        public Task(RentrantLockDemo lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                Thread.sleep(100);\n                System.out.println(\"currentThread\" + Thread.currentThread().getName());\n                System.out.println(\"fairThreads:\" + lock.getQueuedThreads());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Task task = new Task(unfairLock);\n        for (int i = 0; i < 100; i++) {\n            Thread thread = new Thread(task);\n            thread.start();\n        }\n    }\n}\n```\n测试结果如下\n\n```\ncurrentThreadThread-0\nfairThreads:[Thread[Thread-1,5,main], Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-1\nfairThreads:[Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-2\nfairThreads:[Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-3\nfairThreads:[Thread[Thread-4,5,main]]\ncurrentThreadThread-4\nfairThreads:[]\n```\n可以看出，线程会按照等待队列中的顺序依次执行，而非公平锁则不会完全按照顺序来执行","source":"_posts/va-concurrent包下的锁.md","raw":"title: java concurrent包下的锁\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-07-29 16:52:00\nsubtitle:\nheader-img:\n---\n### concurrent包下锁的种类\n- 接口：Lock、ReadWriteLock、Condition\n- 实现类：ReentrantLock、ReentrantReadWriteLock、StampedLock\n- 抽象类：AbstractQueuedSychronizer\n\n简单梳理下锁的关系ReentrantLock实现了Lock接口，并内部实现了AQS同步器；ReentrantReadWriteLock实现了ReadWriteLock接口，并有内部类实现类AQS同步器，可以看出无论上面两种锁实现的关键都是AQS同步器，足以看出想要深入理解锁，必须先掌握AQS同步器，可以查看我的上一篇介绍AQS的博客【[同步队列-AbstractQueuedSyncronizer](https://blog.csdn.net/wmj765/article/details/86539873)】下面将逐一介绍并写demo来理解锁的使用方法。\n\n#### ReentrantLock可重入锁分析及使用\n- volatile int state 状态值，很重要的一个参数，来标识同步状态，可以先将其理解为当前已经获取锁的次数(不准确，为入门者方便理解，后面会具体分析)。\n- sync extends AQS 内部类，继承同步器，需要自己重写tryAcquire()、tryRelease()或者tryAcquireShared()、tryReleaseShared方法；一个是独占锁的实现，一个是可共享的实现\n\n##### 共享锁与独占锁\n\n独占锁的实现上篇博客写了个例子，这里在简单总结下，独占就相当于同时只有一个线程可以获取到锁，其他线程则阻塞在队列中，此时只需在获取锁的时候判断state值是否为0，若为0，则cas自旋将1赋值给state，若为1，则将当前线程放入到队列中，内部结构为双向链表。\n共享锁即同时可以有多个线程获取到锁（CountDownLatch），思路其实和独占锁大体相同，只不过state值将不是以1位分界，下面我自己实现了一个简单的共享锁\n\n```\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/**\n * 自定义共享锁，继承AQS，重写tryAcquireShared/tryReleaseShared\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class CountDownLock {\n    private final class sync extends AbstractQueuedSynchronizer {\n        //自旋CAS将state设置成剩余可进入线程数\n        @Override\n        protected int tryAcquireShared(int reduce) {\n            for (; ; ) {\n                //当前状态值\n                int current = getState();\n                //剩余可进入的线程\n                int rest = current - reduce;\n                //当rest<0将线程任务放入队列等待\n                if (rest < 0 || compareAndSetState(current, rest)) {\n                    return rest;\n                }\n            }\n        }\n\n\n        @Override\n        protected boolean tryReleaseShared(int increment) {\n            for (; ; ) {\n                int current = getState();\n                int newCount = current + increment;\n                if (newCount > 2)\n                    throw new IllegalArgumentException();\n                if (compareAndSetState(current, newCount)) {\n                    return true;\n                }\n            }\n        }\n\n        sync(int count) {\n            if (count < 0)\n                throw new IllegalMonitorStateException();\n            setState(count);\n        }\n    }\n\n    private final sync sync = new sync(2);\n\n    public void lock() {\n        sync.acquireShared(1);\n    }\n\n    public void unLock() {\n        sync.releaseShared(1);\n    }\n}\n```\n上面代码固定实现了可以2个线程共享的功能，继续写一段测试代码来验证是否成功\n\n```\n/**\n * 共享锁测试类 结果应为两个线程同时获取到锁，然后等待1S，即线程成对出现\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class CountDownLockTest {\n\n    static class task implements Runnable {\n        CountDownLock lock = new CountDownLock();\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                Thread.sleep(1000);\n                System.out.println(\"currentThread\" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unLock();\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        task task = new task();\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(task);\n            thread.start();\n        }\n    }\n}\n```\n结果是线程成对出现，并间隔一秒，即同时可以有两个线程来获取到锁\n\n##### 公平锁与非公平锁\n公平锁与非公平锁的主要区别是公平锁会完全按照先入先出的顺序来执行等待队列中的线程，而非公平锁则在获取锁的时候会先尝试当前线程获取到锁，若当前线程获取锁失败，则加入等待队列后和公平锁没有区别，下面我写了个简单的例子来看公平锁和非公平锁\n\n```\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 继承ReentrantLock，重写getQueuedThreads,将当前队列反转成正序\n *\n * @author wangmj\n * @since 2019/1/19\n */\npublic class RentrantLockDemo extends ReentrantLock {\n\n    public RentrantLockDemo(boolean fair) {\n        super(fair);\n    }\n\n    @Override\n    public Collection<Thread> getQueuedThreads() {\n        List list = new ArrayList(super.getQueuedThreads());\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n继续写一个测试类，来测试公平锁与非公平锁\n\n```\n/**\n * 测试公平锁与非公平锁的区别\n *\n * @author wangmj\n * @since 2019/1/19\n */\npublic class ReentrantLockTest {\n    private static RentrantLockDemo fairLock = new RentrantLockDemo(true);\n    private static RentrantLockDemo unfairLock = new RentrantLockDemo(false);\n\n\n    static class Task implements Runnable {\n        private RentrantLockDemo lock;\n\n        public Task(RentrantLockDemo lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                Thread.sleep(100);\n                System.out.println(\"currentThread\" + Thread.currentThread().getName());\n                System.out.println(\"fairThreads:\" + lock.getQueuedThreads());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Task task = new Task(unfairLock);\n        for (int i = 0; i < 100; i++) {\n            Thread thread = new Thread(task);\n            thread.start();\n        }\n    }\n}\n```\n测试结果如下\n\n```\ncurrentThreadThread-0\nfairThreads:[Thread[Thread-1,5,main], Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-1\nfairThreads:[Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-2\nfairThreads:[Thread[Thread-3,5,main], Thread[Thread-4,5,main]]\ncurrentThreadThread-3\nfairThreads:[Thread[Thread-4,5,main]]\ncurrentThreadThread-4\nfairThreads:[]\n```\n可以看出，线程会按照等待队列中的顺序依次执行，而非公平锁则不会完全按照顺序来执行","slug":"va-concurrent包下的锁","published":1,"updated":"2019-06-29T08:54:51.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8f000ikcx1zcft2qag","content":"<h3><span id=\"concurrent包下锁的种类\">concurrent包下锁的种类</span></h3>\n<ul>\n<li>接口：Lock、ReadWriteLock、Condition</li>\n<li>实现类：ReentrantLock、ReentrantReadWriteLock、StampedLock</li>\n<li>抽象类：AbstractQueuedSychronizer</li>\n</ul>\n<p>简单梳理下锁的关系ReentrantLock实现了Lock接口，并内部实现了AQS同步器；ReentrantReadWriteLock实现了ReadWriteLock接口，并有内部类实现类AQS同步器，可以看出无论上面两种锁实现的关键都是AQS同步器，足以看出想要深入理解锁，必须先掌握AQS同步器，可以查看我的上一篇介绍AQS的博客【<a href=\"https://blog.csdn.net/wmj765/article/details/86539873\" target=\"_blank\" rel=\"noopener\">同步队列-AbstractQueuedSyncronizer</a>】下面将逐一介绍并写demo来理解锁的使用方法。</p>\n<h4><span id=\"reentrantlock可重入锁分析及使用\">ReentrantLock可重入锁分析及使用</span></h4>\n<ul>\n<li>volatile int state 状态值，很重要的一个参数，来标识同步状态，可以先将其理解为当前已经获取锁的次数(不准确，为入门者方便理解，后面会具体分析)。</li>\n<li>sync extends AQS 内部类，继承同步器，需要自己重写tryAcquire()、tryRelease()或者tryAcquireShared()、tryReleaseShared方法；一个是独占锁的实现，一个是可共享的实现</li>\n</ul>\n<h5><span id=\"共享锁与独占锁\">共享锁与独占锁</span></h5>\n<p>独占锁的实现上篇博客写了个例子，这里在简单总结下，独占就相当于同时只有一个线程可以获取到锁，其他线程则阻塞在队列中，此时只需在获取锁的时候判断state值是否为0，若为0，则cas自旋将1赋值给state，若为1，则将当前线程放入到队列中，内部结构为双向链表。<br>\n共享锁即同时可以有多个线程获取到锁（CountDownLatch），思路其实和独占锁大体相同，只不过state值将不是以1位分界，下面我自己实现了一个简单的共享锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 自定义共享锁，继承AQS，重写tryAcquireShared/tryReleaseShared</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLock &#123;</span><br><span class=\"line\">    private final class sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        //自旋CAS将state设置成剩余可进入线程数</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected int tryAcquireShared(int reduce) &#123;</span><br><span class=\"line\">            for (; ; ) &#123;</span><br><span class=\"line\">                //当前状态值</span><br><span class=\"line\">                int current = getState();</span><br><span class=\"line\">                //剩余可进入的线程</span><br><span class=\"line\">                int rest = current - reduce;</span><br><span class=\"line\">                //当rest&lt;0将线程任务放入队列等待</span><br><span class=\"line\">                if (rest &lt; 0 || compareAndSetState(current, rest)) &#123;</span><br><span class=\"line\">                    return rest;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryReleaseShared(int increment) &#123;</span><br><span class=\"line\">            for (; ; ) &#123;</span><br><span class=\"line\">                int current = getState();</span><br><span class=\"line\">                int newCount = current + increment;</span><br><span class=\"line\">                if (newCount &gt; 2)</span><br><span class=\"line\">                    throw new IllegalArgumentException();</span><br><span class=\"line\">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sync(int count) &#123;</span><br><span class=\"line\">            if (count &lt; 0)</span><br><span class=\"line\">                throw new IllegalMonitorStateException();</span><br><span class=\"line\">            setState(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final sync sync = new sync(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquireShared(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        sync.releaseShared(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码固定实现了可以2个线程共享的功能，继续写一段测试代码来验证是否成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 共享锁测试类 结果应为两个线程同时获取到锁，然后等待1S，即线程成对出现</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLockTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class task implements Runnable &#123;</span><br><span class=\"line\">        CountDownLock lock = new CountDownLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">                System.out.println(&quot;currentThread&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unLock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        task task = new task();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            Thread thread = new Thread(task);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果是线程成对出现，并间隔一秒，即同时可以有两个线程来获取到锁</p>\n<h5><span id=\"公平锁与非公平锁\">公平锁与非公平锁</span></h5>\n<p>公平锁与非公平锁的主要区别是公平锁会完全按照先入先出的顺序来执行等待队列中的线程，而非公平锁则在获取锁的时候会先尝试当前线程获取到锁，若当前线程获取锁失败，则加入等待队列后和公平锁没有区别，下面我写了个简单的例子来看公平锁和非公平锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.Collection;</span><br><span class=\"line\">import java.util.Collections;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 继承ReentrantLock，重写getQueuedThreads,将当前队列反转成正序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/19</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class RentrantLockDemo extends ReentrantLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RentrantLockDemo(boolean fair) &#123;</span><br><span class=\"line\">        super(fair);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class=\"line\">        List list = new ArrayList(super.getQueuedThreads());</span><br><span class=\"line\">        Collections.reverse(list);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续写一个测试类，来测试公平锁与非公平锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 测试公平锁与非公平锁的区别</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/19</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ReentrantLockTest &#123;</span><br><span class=\"line\">    private static RentrantLockDemo fairLock = new RentrantLockDemo(true);</span><br><span class=\"line\">    private static RentrantLockDemo unfairLock = new RentrantLockDemo(false);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    static class Task implements Runnable &#123;</span><br><span class=\"line\">        private RentrantLockDemo lock;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Task(RentrantLockDemo lock) &#123;</span><br><span class=\"line\">            this.lock = lock;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(100);</span><br><span class=\"line\">                System.out.println(&quot;currentThread&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">                System.out.println(&quot;fairThreads:&quot; + lock.getQueuedThreads());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Task task = new Task(unfairLock);</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            Thread thread = new Thread(task);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentThreadThread-0</span><br><span class=\"line\">fairThreads:[Thread[Thread-1,5,main], Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-1</span><br><span class=\"line\">fairThreads:[Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-2</span><br><span class=\"line\">fairThreads:[Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-3</span><br><span class=\"line\">fairThreads:[Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-4</span><br><span class=\"line\">fairThreads:[]</span><br></pre></td></tr></table></figure>\n<p>可以看出，线程会按照等待队列中的顺序依次执行，而非公平锁则不会完全按照顺序来执行</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>concurrent包下锁的种类</h3>\n<ul>\n<li>接口：Lock、ReadWriteLock、Condition</li>\n<li>实现类：ReentrantLock、ReentrantReadWriteLock、StampedLock</li>\n<li>抽象类：AbstractQueuedSychronizer</li>\n</ul>\n<p>简单梳理下锁的关系ReentrantLock实现了Lock接口，并内部实现了AQS同步器；ReentrantReadWriteLock实现了ReadWriteLock接口，并有内部类实现类AQS同步器，可以看出无论上面两种锁实现的关键都是AQS同步器，足以看出想要深入理解锁，必须先掌握AQS同步器，可以查看我的上一篇介绍AQS的博客【<a href=\"https://blog.csdn.net/wmj765/article/details/86539873\" target=\"_blank\" rel=\"noopener\">同步队列-AbstractQueuedSyncronizer</a>】下面将逐一介绍并写demo来理解锁的使用方法。</p>\n<h4>ReentrantLock可重入锁分析及使用</h4>\n<ul>\n<li>volatile int state 状态值，很重要的一个参数，来标识同步状态，可以先将其理解为当前已经获取锁的次数(不准确，为入门者方便理解，后面会具体分析)。</li>\n<li>sync extends AQS 内部类，继承同步器，需要自己重写tryAcquire()、tryRelease()或者tryAcquireShared()、tryReleaseShared方法；一个是独占锁的实现，一个是可共享的实现</li>\n</ul>\n<h5>共享锁与独占锁</h5>\n<p>独占锁的实现上篇博客写了个例子，这里在简单总结下，独占就相当于同时只有一个线程可以获取到锁，其他线程则阻塞在队列中，此时只需在获取锁的时候判断state值是否为0，若为0，则cas自旋将1赋值给state，若为1，则将当前线程放入到队列中，内部结构为双向链表。<br>\n共享锁即同时可以有多个线程获取到锁（CountDownLatch），思路其实和独占锁大体相同，只不过state值将不是以1位分界，下面我自己实现了一个简单的共享锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 自定义共享锁，继承AQS，重写tryAcquireShared/tryReleaseShared</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLock &#123;</span><br><span class=\"line\">    private final class sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        //自旋CAS将state设置成剩余可进入线程数</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected int tryAcquireShared(int reduce) &#123;</span><br><span class=\"line\">            for (; ; ) &#123;</span><br><span class=\"line\">                //当前状态值</span><br><span class=\"line\">                int current = getState();</span><br><span class=\"line\">                //剩余可进入的线程</span><br><span class=\"line\">                int rest = current - reduce;</span><br><span class=\"line\">                //当rest&lt;0将线程任务放入队列等待</span><br><span class=\"line\">                if (rest &lt; 0 || compareAndSetState(current, rest)) &#123;</span><br><span class=\"line\">                    return rest;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryReleaseShared(int increment) &#123;</span><br><span class=\"line\">            for (; ; ) &#123;</span><br><span class=\"line\">                int current = getState();</span><br><span class=\"line\">                int newCount = current + increment;</span><br><span class=\"line\">                if (newCount &gt; 2)</span><br><span class=\"line\">                    throw new IllegalArgumentException();</span><br><span class=\"line\">                if (compareAndSetState(current, newCount)) &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sync(int count) &#123;</span><br><span class=\"line\">            if (count &lt; 0)</span><br><span class=\"line\">                throw new IllegalMonitorStateException();</span><br><span class=\"line\">            setState(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final sync sync = new sync(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquireShared(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unLock() &#123;</span><br><span class=\"line\">        sync.releaseShared(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码固定实现了可以2个线程共享的功能，继续写一段测试代码来验证是否成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 共享锁测试类 结果应为两个线程同时获取到锁，然后等待1S，即线程成对出现</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLockTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class task implements Runnable &#123;</span><br><span class=\"line\">        CountDownLock lock = new CountDownLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">                System.out.println(&quot;currentThread&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unLock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        task task = new task();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            Thread thread = new Thread(task);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果是线程成对出现，并间隔一秒，即同时可以有两个线程来获取到锁</p>\n<h5>公平锁与非公平锁</h5>\n<p>公平锁与非公平锁的主要区别是公平锁会完全按照先入先出的顺序来执行等待队列中的线程，而非公平锁则在获取锁的时候会先尝试当前线程获取到锁，若当前线程获取锁失败，则加入等待队列后和公平锁没有区别，下面我写了个简单的例子来看公平锁和非公平锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.Collection;</span><br><span class=\"line\">import java.util.Collections;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 继承ReentrantLock，重写getQueuedThreads,将当前队列反转成正序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/19</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class RentrantLockDemo extends ReentrantLock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RentrantLockDemo(boolean fair) &#123;</span><br><span class=\"line\">        super(fair);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Collection&lt;Thread&gt; getQueuedThreads() &#123;</span><br><span class=\"line\">        List list = new ArrayList(super.getQueuedThreads());</span><br><span class=\"line\">        Collections.reverse(list);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续写一个测试类，来测试公平锁与非公平锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 测试公平锁与非公平锁的区别</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/19</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ReentrantLockTest &#123;</span><br><span class=\"line\">    private static RentrantLockDemo fairLock = new RentrantLockDemo(true);</span><br><span class=\"line\">    private static RentrantLockDemo unfairLock = new RentrantLockDemo(false);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    static class Task implements Runnable &#123;</span><br><span class=\"line\">        private RentrantLockDemo lock;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Task(RentrantLockDemo lock) &#123;</span><br><span class=\"line\">            this.lock = lock;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(100);</span><br><span class=\"line\">                System.out.println(&quot;currentThread&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">                System.out.println(&quot;fairThreads:&quot; + lock.getQueuedThreads());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Task task = new Task(unfairLock);</span><br><span class=\"line\">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            Thread thread = new Thread(task);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentThreadThread-0</span><br><span class=\"line\">fairThreads:[Thread[Thread-1,5,main], Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-1</span><br><span class=\"line\">fairThreads:[Thread[Thread-2,5,main], Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-2</span><br><span class=\"line\">fairThreads:[Thread[Thread-3,5,main], Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-3</span><br><span class=\"line\">fairThreads:[Thread[Thread-4,5,main]]</span><br><span class=\"line\">currentThreadThread-4</span><br><span class=\"line\">fairThreads:[]</span><br></pre></td></tr></table></figure>\n<p>可以看出，线程会按照等待队列中的顺序依次执行，而非公平锁则不会完全按照顺序来执行</p>\n"},{"title":"java基础之集合框架--LinkedHashMap深入理解","catalog":true,"author":"wangmj","date":"2018-01-10T08:36:00.000Z","subtitle":null,"header-img":null,"_content":"### java基础之集合框架--LinkedHashMap深入理解\n在看LinkedHashMap时还是建议先回顾下HashMap--LinkedHashMap的父亲，是不是感觉HashMap很重要，哈哈~~，它就是很重要，可以把它比作一个美轮美奂的精美建筑，一切设计都那么恰到好处！\n[ java基础之集合框架--HashMap深入理解及应用](http://blog.csdn.net/wmj765/article/details/78427680)\n\n#### LinkedHashMap底层结构图\nLinkedHashMap底层为数组和双向链表，它继承了HashMap,生成数组index的逻辑与hashMap完全相同，只不过linkedHashMap的Entry里面多了两个元素，before和after，并定义了一个不可序列化的header，存储时，将第一个元素赋值给header，并将before指向header，下个元素put时，将上个元素的after指向此元素，并将此元素的before指向上个元素，最终则形成了图中的结构。\n\n![这里写图片描述](http://img.blog.csdn.net/20171117161131083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n#### LinkedHashMap之 put方法源码分析\n我们知道，linkedHashMap继承了HashMap,它没有重写父类的put方法，所以调用时还会调用父类的put，但是其重写了hashMap的newNode方法，下面是关键代码，当put新值得时候，其会调用newNode方法；\n\n```\n\t//初始化Node\n      Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n        //形成双向链表\n        linkNodeLast(p);\n        return p;\n    }\n\n\t//初始化linkedHashMap的Entry\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n\n\t//组成双向链表\n    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n        LinkedHashMap.Entry<K,V> last = tail;\n        tail = p;\n        if (last == null)//第一次put值将值赋值给head\n            head = p;\n        else {//双向链表\n            p.before = last;\n            last.after = p;\n        }\n    }\n```\n\n上面为put的关键代码，基本思路就是相较于hashMap的entry多加了三个属性，head、before、after；head为static变量，当第一次put值A得时候将A赋值给head，并将A.before指向head，A.after为null，第二次put值B时将B.before指向A，并将A.after指向B，B.after为null.......以此类推，即可形成双向链表。\n\n#### LinkedHashMap之 遍历源码分析\n\n遍历之前，先把head赋值给next元素，然后调用内部类nextNode()方法，然后回依次去掉用next.after来取元素，直到next.after=head结束；伪代码类似这种for (LinkedHashMap.Entry e = head; e != null; e = e.after)\n\n```\n    abstract class LinkedHashIterator {\n        LinkedHashMap.Entry<K,V> next;\n        LinkedHashMap.Entry<K,V> current;\n        int expectedModCount;\n\n        LinkedHashIterator() {\n            next = head;//将next赋值给head\n            expectedModCount = modCount;\n            current = null;\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n\t\t//遍历\n        final LinkedHashMap.Entry<K,V> nextNode() {\n            LinkedHashMap.Entry<K,V> e = next;\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (e == null)\n                throw new NoSuchElementException();\n            current = e;\n            next = e.after;\n            return e;\n        }\n\n        public final void remove() {\n            Node<K,V> p = current;\n            if (p == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            current = null;\n            K key = p.key;\n            removeNode(hash(key), key, null, false, false);\n            expectedModCount = modCount;\n        }\n    }\n```\n\n以上就是LinkedHashMap分析","source":"_posts/va基础之集合框架-LinkedHashMap深入理解.md","raw":"title: java基础之集合框架--LinkedHashMap深入理解\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-01-10 16:36:00\nsubtitle:\nheader-img:\n---\n### java基础之集合框架--LinkedHashMap深入理解\n在看LinkedHashMap时还是建议先回顾下HashMap--LinkedHashMap的父亲，是不是感觉HashMap很重要，哈哈~~，它就是很重要，可以把它比作一个美轮美奂的精美建筑，一切设计都那么恰到好处！\n[ java基础之集合框架--HashMap深入理解及应用](http://blog.csdn.net/wmj765/article/details/78427680)\n\n#### LinkedHashMap底层结构图\nLinkedHashMap底层为数组和双向链表，它继承了HashMap,生成数组index的逻辑与hashMap完全相同，只不过linkedHashMap的Entry里面多了两个元素，before和after，并定义了一个不可序列化的header，存储时，将第一个元素赋值给header，并将before指向header，下个元素put时，将上个元素的after指向此元素，并将此元素的before指向上个元素，最终则形成了图中的结构。\n\n![这里写图片描述](http://img.blog.csdn.net/20171117161131083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n#### LinkedHashMap之 put方法源码分析\n我们知道，linkedHashMap继承了HashMap,它没有重写父类的put方法，所以调用时还会调用父类的put，但是其重写了hashMap的newNode方法，下面是关键代码，当put新值得时候，其会调用newNode方法；\n\n```\n\t//初始化Node\n      Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n        LinkedHashMap.Entry<K,V> p =\n            new LinkedHashMap.Entry<K,V>(hash, key, value, e);\n        //形成双向链表\n        linkNodeLast(p);\n        return p;\n    }\n\n\t//初始化linkedHashMap的Entry\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n\n\t//组成双向链表\n    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n        LinkedHashMap.Entry<K,V> last = tail;\n        tail = p;\n        if (last == null)//第一次put值将值赋值给head\n            head = p;\n        else {//双向链表\n            p.before = last;\n            last.after = p;\n        }\n    }\n```\n\n上面为put的关键代码，基本思路就是相较于hashMap的entry多加了三个属性，head、before、after；head为static变量，当第一次put值A得时候将A赋值给head，并将A.before指向head，A.after为null，第二次put值B时将B.before指向A，并将A.after指向B，B.after为null.......以此类推，即可形成双向链表。\n\n#### LinkedHashMap之 遍历源码分析\n\n遍历之前，先把head赋值给next元素，然后调用内部类nextNode()方法，然后回依次去掉用next.after来取元素，直到next.after=head结束；伪代码类似这种for (LinkedHashMap.Entry e = head; e != null; e = e.after)\n\n```\n    abstract class LinkedHashIterator {\n        LinkedHashMap.Entry<K,V> next;\n        LinkedHashMap.Entry<K,V> current;\n        int expectedModCount;\n\n        LinkedHashIterator() {\n            next = head;//将next赋值给head\n            expectedModCount = modCount;\n            current = null;\n        }\n\n        public final boolean hasNext() {\n            return next != null;\n        }\n\n\t\t//遍历\n        final LinkedHashMap.Entry<K,V> nextNode() {\n            LinkedHashMap.Entry<K,V> e = next;\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (e == null)\n                throw new NoSuchElementException();\n            current = e;\n            next = e.after;\n            return e;\n        }\n\n        public final void remove() {\n            Node<K,V> p = current;\n            if (p == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            current = null;\n            K key = p.key;\n            removeNode(hash(key), key, null, false, false);\n            expectedModCount = modCount;\n        }\n    }\n```\n\n以上就是LinkedHashMap分析","slug":"va基础之集合框架-LinkedHashMap深入理解","published":1,"updated":"2019-06-29T08:38:51.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8g000kkcx1a9rbxyn7","content":"<h3><span id=\"java基础之集合框架linkedhashmap深入理解\">java基础之集合框架–LinkedHashMap深入理解</span></h3>\n<p>在看LinkedHashMap时还是建议先回顾下HashMap–LinkedHashMap的父亲，是不是感觉HashMap很重要，哈哈~~，它就是很重要，可以把它比作一个美轮美奂的精美建筑，一切设计都那么恰到好处！<br>\n<a href=\"http://blog.csdn.net/wmj765/article/details/78427680\" target=\"_blank\" rel=\"noopener\"> java基础之集合框架–HashMap深入理解及应用</a></p>\n<h4><span id=\"linkedhashmap底层结构图\">LinkedHashMap底层结构图</span></h4>\n<p>LinkedHashMap底层为数组和双向链表，它继承了HashMap,生成数组index的逻辑与hashMap完全相同，只不过linkedHashMap的Entry里面多了两个元素，before和after，并定义了一个不可序列化的header，存储时，将第一个元素赋值给header，并将before指向header，下个元素put时，将上个元素的after指向此元素，并将此元素的before指向上个元素，最终则形成了图中的结构。</p>\n<p><img src=\"http://img.blog.csdn.net/20171117161131083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4><span id=\"linkedhashmap之-put方法源码分析\">LinkedHashMap之 put方法源码分析</span></h4>\n<p>我们知道，linkedHashMap继承了HashMap,它没有重写父类的put方法，所以调用时还会调用父类的put，但是其重写了hashMap的newNode方法，下面是关键代码，当put新值得时候，其会调用newNode方法；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//初始化Node</span><br><span class=\"line\">     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class=\"line\">       LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">           new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">       //形成双向链表</span><br><span class=\"line\">       linkNodeLast(p);</span><br><span class=\"line\">       return p;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化linkedHashMap的Entry</span><br><span class=\"line\">   static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class=\"line\">       Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">       Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">           super(hash, key, value, next);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//组成双向链表</span><br><span class=\"line\">   private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class=\"line\">       LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">       tail = p;</span><br><span class=\"line\">       if (last == null)//第一次put值将值赋值给head</span><br><span class=\"line\">           head = p;</span><br><span class=\"line\">       else &#123;//双向链表</span><br><span class=\"line\">           p.before = last;</span><br><span class=\"line\">           last.after = p;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>上面为put的关键代码，基本思路就是相较于hashMap的entry多加了三个属性，head、before、after；head为static变量，当第一次put值A得时候将A赋值给head，并将A.before指向head，A.after为null，第二次put值B时将B.before指向A，并将A.after指向B，B.after为null…以此类推，即可形成双向链表。</p>\n<h4><span id=\"linkedhashmap之-遍历源码分析\">LinkedHashMap之 遍历源码分析</span></h4>\n<p>遍历之前，先把head赋值给next元素，然后调用内部类nextNode()方法，然后回依次去掉用next.after来取元素，直到next.after=head结束；伪代码类似这种for (LinkedHashMap.Entry e = head; e != null; e = e.after)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  abstract class LinkedHashIterator &#123;</span><br><span class=\"line\">      LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class=\"line\">      LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class=\"line\">      int expectedModCount;</span><br><span class=\"line\"></span><br><span class=\"line\">      LinkedHashIterator() &#123;</span><br><span class=\"line\">          next = head;//将next赋值给head</span><br><span class=\"line\">          expectedModCount = modCount;</span><br><span class=\"line\">          current = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final boolean hasNext() &#123;</span><br><span class=\"line\">          return next != null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历</span><br><span class=\"line\">      final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class=\"line\">          LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class=\"line\">          if (modCount != expectedModCount)</span><br><span class=\"line\">              throw new ConcurrentModificationException();</span><br><span class=\"line\">          if (e == null)</span><br><span class=\"line\">              throw new NoSuchElementException();</span><br><span class=\"line\">          current = e;</span><br><span class=\"line\">          next = e.after;</span><br><span class=\"line\">          return e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final void remove() &#123;</span><br><span class=\"line\">          Node&lt;K,V&gt; p = current;</span><br><span class=\"line\">          if (p == null)</span><br><span class=\"line\">              throw new IllegalStateException();</span><br><span class=\"line\">          if (modCount != expectedModCount)</span><br><span class=\"line\">              throw new ConcurrentModificationException();</span><br><span class=\"line\">          current = null;</span><br><span class=\"line\">          K key = p.key;</span><br><span class=\"line\">          removeNode(hash(key), key, null, false, false);</span><br><span class=\"line\">          expectedModCount = modCount;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是LinkedHashMap分析</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>java基础之集合框架–LinkedHashMap深入理解</h3>\n<p>在看LinkedHashMap时还是建议先回顾下HashMap–LinkedHashMap的父亲，是不是感觉HashMap很重要，哈哈~~，它就是很重要，可以把它比作一个美轮美奂的精美建筑，一切设计都那么恰到好处！<br>\n<a href=\"http://blog.csdn.net/wmj765/article/details/78427680\" target=\"_blank\" rel=\"noopener\"> java基础之集合框架–HashMap深入理解及应用</a></p>\n<h4>LinkedHashMap底层结构图</h4>\n<p>LinkedHashMap底层为数组和双向链表，它继承了HashMap,生成数组index的逻辑与hashMap完全相同，只不过linkedHashMap的Entry里面多了两个元素，before和after，并定义了一个不可序列化的header，存储时，将第一个元素赋值给header，并将before指向header，下个元素put时，将上个元素的after指向此元素，并将此元素的before指向上个元素，最终则形成了图中的结构。</p>\n<p><img src=\"http://img.blog.csdn.net/20171117161131083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h4>LinkedHashMap之 put方法源码分析</h4>\n<p>我们知道，linkedHashMap继承了HashMap,它没有重写父类的put方法，所以调用时还会调用父类的put，但是其重写了hashMap的newNode方法，下面是关键代码，当put新值得时候，其会调用newNode方法；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//初始化Node</span><br><span class=\"line\">     Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class=\"line\">       LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class=\"line\">           new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">       //形成双向链表</span><br><span class=\"line\">       linkNodeLast(p);</span><br><span class=\"line\">       return p;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化linkedHashMap的Entry</span><br><span class=\"line\">   static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class=\"line\">       Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">       Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">           super(hash, key, value, next);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//组成双向链表</span><br><span class=\"line\">   private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class=\"line\">       LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">       tail = p;</span><br><span class=\"line\">       if (last == null)//第一次put值将值赋值给head</span><br><span class=\"line\">           head = p;</span><br><span class=\"line\">       else &#123;//双向链表</span><br><span class=\"line\">           p.before = last;</span><br><span class=\"line\">           last.after = p;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>上面为put的关键代码，基本思路就是相较于hashMap的entry多加了三个属性，head、before、after；head为static变量，当第一次put值A得时候将A赋值给head，并将A.before指向head，A.after为null，第二次put值B时将B.before指向A，并将A.after指向B，B.after为null…以此类推，即可形成双向链表。</p>\n<h4>LinkedHashMap之 遍历源码分析</h4>\n<p>遍历之前，先把head赋值给next元素，然后调用内部类nextNode()方法，然后回依次去掉用next.after来取元素，直到next.after=head结束；伪代码类似这种for (LinkedHashMap.Entry e = head; e != null; e = e.after)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  abstract class LinkedHashIterator &#123;</span><br><span class=\"line\">      LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class=\"line\">      LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class=\"line\">      int expectedModCount;</span><br><span class=\"line\"></span><br><span class=\"line\">      LinkedHashIterator() &#123;</span><br><span class=\"line\">          next = head;//将next赋值给head</span><br><span class=\"line\">          expectedModCount = modCount;</span><br><span class=\"line\">          current = null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final boolean hasNext() &#123;</span><br><span class=\"line\">          return next != null;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历</span><br><span class=\"line\">      final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class=\"line\">          LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class=\"line\">          if (modCount != expectedModCount)</span><br><span class=\"line\">              throw new ConcurrentModificationException();</span><br><span class=\"line\">          if (e == null)</span><br><span class=\"line\">              throw new NoSuchElementException();</span><br><span class=\"line\">          current = e;</span><br><span class=\"line\">          next = e.after;</span><br><span class=\"line\">          return e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public final void remove() &#123;</span><br><span class=\"line\">          Node&lt;K,V&gt; p = current;</span><br><span class=\"line\">          if (p == null)</span><br><span class=\"line\">              throw new IllegalStateException();</span><br><span class=\"line\">          if (modCount != expectedModCount)</span><br><span class=\"line\">              throw new ConcurrentModificationException();</span><br><span class=\"line\">          current = null;</span><br><span class=\"line\">          K key = p.key;</span><br><span class=\"line\">          removeNode(hash(key), key, null, false, false);</span><br><span class=\"line\">          expectedModCount = modCount;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是LinkedHashMap分析</p>\n"},{"title":"java基础之集合框架--HashSet深入理解","catalog":true,"author":"wangmj","date":"2018-01-01T08:34:00.000Z","subtitle":null,"header-img":null,"_content":"###HashSet深入理解\n前几天分析了HashMap,看懂hashMap后，再来看HashSet就简单多了，其实HashSet底层就初始化时即调用了HashMap，在看HashSet时建议先回顾下HashMap\n[ java基础之集合框架--HashMap深入理解及应用](http://blog.csdn.net/wmj765/article/details/78427680)\n\n#### HashSet源码分析\n我们直接来看下hashset的源码，可以看到当我们初始化对象时，其实是初始化了一个hashmap，其他的有参构造器也分别调用了hashMap的有参构造方法，代码中就不展示了。\n\n```\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n{\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap<E,Object> map;\n\n    //存放HashMap的value，我们add时传的是key，value为new Object()\n    private static final Object PRESENT = new Object();\n\n    //无参构造器，其实就是一个hashMap\n    public HashSet() {\n        map = new HashMap<>();\n    }\n```\n#### HashSet常用方法\n再来看看HashSet的常用方法，size方法、add方法、遍历等等，其实都是调用map中的方法，其他方法就不一一列举了，在add方法时，map.put方法，key为add的对象，value为new　Object()；\n\n```\n//大小\npublic int size() {\n        return map.size();\n    }\n    \n//添加元素，若不重复返回true\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n\n//遍历\npublic Iterator<E> iterator() {\n        return map.keySet().iterator();\n    }\n```\n\n其实只要我们get到hashMap，其实同时你也完全了解了HashSet；\n最后有一个问题大家思考下，有一组学生，想要放进一个集合中，放在什么集合中能保证取出来的时候有序？HashSet/HashMap可以么","source":"_posts/va基础之集合框架-HashSet深入理解.md","raw":"title: java基础之集合框架--HashSet深入理解\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-01-01 16:34:00\nsubtitle:\nheader-img:\n---\n###HashSet深入理解\n前几天分析了HashMap,看懂hashMap后，再来看HashSet就简单多了，其实HashSet底层就初始化时即调用了HashMap，在看HashSet时建议先回顾下HashMap\n[ java基础之集合框架--HashMap深入理解及应用](http://blog.csdn.net/wmj765/article/details/78427680)\n\n#### HashSet源码分析\n我们直接来看下hashset的源码，可以看到当我们初始化对象时，其实是初始化了一个hashmap，其他的有参构造器也分别调用了hashMap的有参构造方法，代码中就不展示了。\n\n```\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n{\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap<E,Object> map;\n\n    //存放HashMap的value，我们add时传的是key，value为new Object()\n    private static final Object PRESENT = new Object();\n\n    //无参构造器，其实就是一个hashMap\n    public HashSet() {\n        map = new HashMap<>();\n    }\n```\n#### HashSet常用方法\n再来看看HashSet的常用方法，size方法、add方法、遍历等等，其实都是调用map中的方法，其他方法就不一一列举了，在add方法时，map.put方法，key为add的对象，value为new　Object()；\n\n```\n//大小\npublic int size() {\n        return map.size();\n    }\n    \n//添加元素，若不重复返回true\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n\n//遍历\npublic Iterator<E> iterator() {\n        return map.keySet().iterator();\n    }\n```\n\n其实只要我们get到hashMap，其实同时你也完全了解了HashSet；\n最后有一个问题大家思考下，有一组学生，想要放进一个集合中，放在什么集合中能保证取出来的时候有序？HashSet/HashMap可以么","slug":"va基础之集合框架-HashSet深入理解","published":1,"updated":"2019-06-29T08:36:57.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8h000mkcx10l6y5ram","content":"<p>###HashSet深入理解<br>\n前几天分析了HashMap,看懂hashMap后，再来看HashSet就简单多了，其实HashSet底层就初始化时即调用了HashMap，在看HashSet时建议先回顾下HashMap<br>\n<a href=\"http://blog.csdn.net/wmj765/article/details/78427680\" target=\"_blank\" rel=\"noopener\"> java基础之集合框架–HashMap深入理解及应用</a></p>\n<h4><span id=\"hashset源码分析\">HashSet源码分析</span></h4>\n<p>我们直接来看下hashset的源码，可以看到当我们初始化对象时，其实是初始化了一个hashmap，其他的有参构造器也分别调用了hashMap的有参构造方法，代码中就不展示了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HashSet&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSet&lt;E&gt;</span><br><span class=\"line\">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static final long serialVersionUID = -5024744406713321676L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    //存放HashMap的value，我们add时传的是key，value为new Object()</span><br><span class=\"line\">    private static final Object PRESENT = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    //无参构造器，其实就是一个hashMap</span><br><span class=\"line\">    public HashSet() &#123;</span><br><span class=\"line\">        map = new HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"hashset常用方法\">HashSet常用方法</span></h4>\n<p>再来看看HashSet的常用方法，size方法、add方法、遍历等等，其实都是调用map中的方法，其他方法就不一一列举了，在add方法时，map.put方法，key为add的对象，value为new　Object()；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//大小</span><br><span class=\"line\">public int size() &#123;</span><br><span class=\"line\">        return map.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">//添加元素，若不重复返回true</span><br><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">        return map.put(e, PRESENT)==null;</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历</span><br><span class=\"line\">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class=\"line\">        return map.keySet().iterator();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其实只要我们get到hashMap，其实同时你也完全了解了HashSet；<br>\n最后有一个问题大家思考下，有一组学生，想要放进一个集合中，放在什么集合中能保证取出来的时候有序？HashSet/HashMap可以么</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###HashSet深入理解<br>\n前几天分析了HashMap,看懂hashMap后，再来看HashSet就简单多了，其实HashSet底层就初始化时即调用了HashMap，在看HashSet时建议先回顾下HashMap<br>\n<a href=\"http://blog.csdn.net/wmj765/article/details/78427680\" target=\"_blank\" rel=\"noopener\"> java基础之集合框架–HashMap深入理解及应用</a></p>\n<h4>HashSet源码分析</h4>\n<p>我们直接来看下hashset的源码，可以看到当我们初始化对象时，其实是初始化了一个hashmap，其他的有参构造器也分别调用了hashMap的有参构造方法，代码中就不展示了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HashSet&lt;E&gt;</span><br><span class=\"line\">    extends AbstractSet&lt;E&gt;</span><br><span class=\"line\">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static final long serialVersionUID = -5024744406713321676L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\">    //存放HashMap的value，我们add时传的是key，value为new Object()</span><br><span class=\"line\">    private static final Object PRESENT = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    //无参构造器，其实就是一个hashMap</span><br><span class=\"line\">    public HashSet() &#123;</span><br><span class=\"line\">        map = new HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4>HashSet常用方法</h4>\n<p>再来看看HashSet的常用方法，size方法、add方法、遍历等等，其实都是调用map中的方法，其他方法就不一一列举了，在add方法时，map.put方法，key为add的对象，value为new　Object()；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//大小</span><br><span class=\"line\">public int size() &#123;</span><br><span class=\"line\">        return map.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">//添加元素，若不重复返回true</span><br><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">        return map.put(e, PRESENT)==null;</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历</span><br><span class=\"line\">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class=\"line\">        return map.keySet().iterator();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其实只要我们get到hashMap，其实同时你也完全了解了HashSet；<br>\n最后有一个问题大家思考下，有一组学生，想要放进一个集合中，放在什么集合中能保证取出来的时候有序？HashSet/HashMap可以么</p>\n"},{"title":"mysql 拆分以逗号隔开的字段并应用在in查询","catalog":true,"author":"wangmj","header-img":"Demo.png","date":"2017-04-18T10:26:00.000Z","subtitle":null,"_content":"# mysql 拆分以逗号隔开的字段并应用在in查询\n\n利用substring_index及笛卡尔积来循环拆分sql字段；\n\n首先建立几条数据\n\n| id      |    value |\n| :-------- |  :--: |\n| Computer  |  5,ddd,eee   |\n| Phone     |    12,3333,11  |\n| Pipe      |   234  |\n\n假如我们需要查询的字段in phone字段的值(12,3333,11)，我们可以用一下方法\n\n###具体方法\n```python\n准备示例数据\ncreate table tbl_name (ID int ,mSize varchar(100));\ninsert into tbl_name values (1,'tiny,small,big');\ninsert into tbl_name values (2,'small,medium');\ninsert into tbl_name values (3,'tiny,big');\n\n实现行列转换的SQL\nselect * from table where phone in (\n\tselect  \n\t\tsubstring_index(substring_index(a.mSize,','\n\t\t,b.help_topic_id+1),',',-1) \n\tfrom \n\t\ttbl_name a\n\tjoin\n\t\tmysql.help_topic b\n\t\ton b.help_topic_id < (length(a.mSize) -     length(replace(a.mSize,',',''))+1)\n\torder by a.ID;\n)\n```\n\n\n**原理分析**　\n这个join最基本原理是笛卡尔积。通过这个方式来实现循环。 以下是具体问题分析： length(a.Size) - length(replace(a.mSize,',',''))+1 表示了，按照逗号分割后，改列拥有的数值数量，下面简称n join过程的伪代码：\n```python\n根据ID进行循环\n{\n    判断：i 是否 <= n\n    {\n        获取最靠近第 i 个逗号之前的数据， 即 substring_index(substring_index(a.mSize,',',b.ID),',',-1)\n        i = i +1 \n    }\n    ID = ID +1 \n}\n```\n以上及实现了字段按逗号分隔来用作in的子查询","source":"_posts/ysql-拆分以逗号隔开的字段并应用在in查询.md","raw":"title: mysql 拆分以逗号隔开的字段并应用在in查询\ncatalog: true\nauthor: wangmj\nheader-img: Demo.png\ntags: []\ncategories: []\ndate: 2017-04-18 18:26:00\nsubtitle:\n---\n# mysql 拆分以逗号隔开的字段并应用在in查询\n\n利用substring_index及笛卡尔积来循环拆分sql字段；\n\n首先建立几条数据\n\n| id      |    value |\n| :-------- |  :--: |\n| Computer  |  5,ddd,eee   |\n| Phone     |    12,3333,11  |\n| Pipe      |   234  |\n\n假如我们需要查询的字段in phone字段的值(12,3333,11)，我们可以用一下方法\n\n###具体方法\n```python\n准备示例数据\ncreate table tbl_name (ID int ,mSize varchar(100));\ninsert into tbl_name values (1,'tiny,small,big');\ninsert into tbl_name values (2,'small,medium');\ninsert into tbl_name values (3,'tiny,big');\n\n实现行列转换的SQL\nselect * from table where phone in (\n\tselect  \n\t\tsubstring_index(substring_index(a.mSize,','\n\t\t,b.help_topic_id+1),',',-1) \n\tfrom \n\t\ttbl_name a\n\tjoin\n\t\tmysql.help_topic b\n\t\ton b.help_topic_id < (length(a.mSize) -     length(replace(a.mSize,',',''))+1)\n\torder by a.ID;\n)\n```\n\n\n**原理分析**　\n这个join最基本原理是笛卡尔积。通过这个方式来实现循环。 以下是具体问题分析： length(a.Size) - length(replace(a.mSize,',',''))+1 表示了，按照逗号分割后，改列拥有的数值数量，下面简称n join过程的伪代码：\n```python\n根据ID进行循环\n{\n    判断：i 是否 <= n\n    {\n        获取最靠近第 i 个逗号之前的数据， 即 substring_index(substring_index(a.mSize,',',b.ID),',',-1)\n        i = i +1 \n    }\n    ID = ID +1 \n}\n```\n以上及实现了字段按逗号分隔来用作in的子查询","slug":"ysql-拆分以逗号隔开的字段并应用在in查询","published":1,"updated":"2019-06-29T08:46:08.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8i000nkcx1y63vvrz8","content":"<h1><span id=\"mysql-拆分以逗号隔开的字段并应用在in查询\">mysql 拆分以逗号隔开的字段并应用在in查询</span></h1>\n<p>利用substring_index及笛卡尔积来循环拆分sql字段；</p>\n<p>首先建立几条数据</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">id</th>\n<th style=\"text-align:center\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Computer</td>\n<td style=\"text-align:center\">5,ddd,eee</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Phone</td>\n<td style=\"text-align:center\">12,3333,11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Pipe</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<p>假如我们需要查询的字段in phone字段的值(12,3333,11)，我们可以用一下方法</p>\n<p>###具体方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">准备示例数据</span><br><span class=\"line\">create table tbl_name (ID int ,mSize varchar(<span class=\"number\">100</span>));</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">1</span>,<span class=\"string\">'tiny,small,big'</span>);</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">2</span>,<span class=\"string\">'small,medium'</span>);</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">3</span>,<span class=\"string\">'tiny,big'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">实现行列转换的SQL</span><br><span class=\"line\">select * <span class=\"keyword\">from</span> table where phone <span class=\"keyword\">in</span> (</span><br><span class=\"line\">\tselect  </span><br><span class=\"line\">\t\tsubstring_index(substring_index(a.mSize,<span class=\"string\">','</span></span><br><span class=\"line\">\t\t,b.help_topic_id+<span class=\"number\">1</span>),<span class=\"string\">','</span>,<span class=\"number\">-1</span>) </span><br><span class=\"line\">\t<span class=\"keyword\">from</span> </span><br><span class=\"line\">\t\ttbl_name a</span><br><span class=\"line\">\tjoin</span><br><span class=\"line\">\t\tmysql.help_topic b</span><br><span class=\"line\">\t\ton b.help_topic_id &lt; (length(a.mSize) -     length(replace(a.mSize,<span class=\"string\">','</span>,<span class=\"string\">''</span>))+<span class=\"number\">1</span>)</span><br><span class=\"line\">\torder by a.ID;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><strong>原理分析</strong>　<br>\n这个join最基本原理是笛卡尔积。通过这个方式来实现循环。 以下是具体问题分析： length(a.Size) - length(replace(a.mSize,’,’,’’))+1 表示了，按照逗号分割后，改列拥有的数值数量，下面简称n join过程的伪代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据ID进行循环</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    判断：i 是否 &lt;= n</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        获取最靠近第 i 个逗号之前的数据， 即 substring_index(substring_index(a.mSize,<span class=\"string\">','</span>,b.ID),<span class=\"string\">','</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">        i = i +<span class=\"number\">1</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ID = ID +<span class=\"number\">1</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上及实现了字段按逗号分隔来用作in的子查询</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>mysql 拆分以逗号隔开的字段并应用在in查询</h1>\n<p>利用substring_index及笛卡尔积来循环拆分sql字段；</p>\n<p>首先建立几条数据</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">id</th>\n<th style=\"text-align:center\">value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Computer</td>\n<td style=\"text-align:center\">5,ddd,eee</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Phone</td>\n<td style=\"text-align:center\">12,3333,11</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Pipe</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<p>假如我们需要查询的字段in phone字段的值(12,3333,11)，我们可以用一下方法</p>\n<p>###具体方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">准备示例数据</span><br><span class=\"line\">create table tbl_name (ID int ,mSize varchar(<span class=\"number\">100</span>));</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">1</span>,<span class=\"string\">'tiny,small,big'</span>);</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">2</span>,<span class=\"string\">'small,medium'</span>);</span><br><span class=\"line\">insert into tbl_name values (<span class=\"number\">3</span>,<span class=\"string\">'tiny,big'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">实现行列转换的SQL</span><br><span class=\"line\">select * <span class=\"keyword\">from</span> table where phone <span class=\"keyword\">in</span> (</span><br><span class=\"line\">\tselect  </span><br><span class=\"line\">\t\tsubstring_index(substring_index(a.mSize,<span class=\"string\">','</span></span><br><span class=\"line\">\t\t,b.help_topic_id+<span class=\"number\">1</span>),<span class=\"string\">','</span>,<span class=\"number\">-1</span>) </span><br><span class=\"line\">\t<span class=\"keyword\">from</span> </span><br><span class=\"line\">\t\ttbl_name a</span><br><span class=\"line\">\tjoin</span><br><span class=\"line\">\t\tmysql.help_topic b</span><br><span class=\"line\">\t\ton b.help_topic_id &lt; (length(a.mSize) -     length(replace(a.mSize,<span class=\"string\">','</span>,<span class=\"string\">''</span>))+<span class=\"number\">1</span>)</span><br><span class=\"line\">\torder by a.ID;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><strong>原理分析</strong>　<br>\n这个join最基本原理是笛卡尔积。通过这个方式来实现循环。 以下是具体问题分析： length(a.Size) - length(replace(a.mSize,’,’,’’))+1 表示了，按照逗号分割后，改列拥有的数值数量，下面简称n join过程的伪代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据ID进行循环</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    判断：i 是否 &lt;= n</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        获取最靠近第 i 个逗号之前的数据， 即 substring_index(substring_index(a.mSize,<span class=\"string\">','</span>,b.ID),<span class=\"string\">','</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">        i = i +<span class=\"number\">1</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ID = ID +<span class=\"number\">1</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上及实现了字段按逗号分隔来用作in的子查询</p>\n"},{"title":"java并发编程--线程封闭","catalog":true,"author":"wangmj","date":"2018-04-08T08:37:00.000Z","subtitle":null,"header-img":null,"_content":"#java并发编程--线程封闭\n\n线程封闭有三种方式：Ad-hoc线程封闭、栈封闭、ThreadLocal类；其中Ad-hoc线程封闭一般由程序员自己实现，很少用，暂不介绍。\n\n - 加粗    `Ctrl + B` \n - 插入代码    `Ctrl + K`\n\n\n## 栈封闭\n\n> 将对象封闭在局部变量中，只有局部变量才能访问，保证线程安全。 \n\n下面我们来看一段简单的代码\n\n```\npublic class Animals {\n    Ark ark;\n    Species species;\n    Gender gender;\n\n    public int loadTheArk(Collection<Animal> candidates) {\n        SortedSet<Animal> animals;\n        int numPairs = 0;\n        Animal candidate = null;\n\n        // 被封闭在局部方法中，不要让他溢出\n        animals = new TreeSet<Animal>(new SpeciesGenderComparator());\n        animals.addAll(candidates);\n        for (Animal a : animals) {\n            if (candidate == null || !candidate.isPotentialMate(a))\n                candidate = a;\n            else {\n                ark.load(new AnimalPair(candidate, a));\n                ++numPairs;\n                candidate = null;\n            }\n        }\n        return numPairs;\n    }\n\n\n    class Animal {\n        Species species;\n        Gender gender;\n\n        public boolean isPotentialMate(Animal other) {\n            return species == other.species && gender != other.gender;\n        }\n    }\n\n    enum Species {\n        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,\n        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,\n        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,\n        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA\n    }\n\n    enum Gender {\n        MALE, FEMALE\n    }\n\n    class AnimalPair {\n        private final Animal one, two;\n\n        public AnimalPair(Animal one, Animal two) {\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    class SpeciesGenderComparator implements Comparator<Animal> {\n        public int compare(Animal one, Animal two) {\n            int speciesCompare = one.species.compareTo(two.species);\n            return (speciesCompare != 0)\n                    ? speciesCompare\n                    : one.gender.compareTo(two.gender);\n        }\n    }\n\n    class Ark {\n        private final Set<AnimalPair> loadedAnimals = new HashSet<AnimalPair>();\n\n        public void load(AnimalPair pair) {\n            loadedAnimals.add(pair);\n        }\n    }\n}\n```\n\nanimals被封装在一个局部变量treeset中，并将指向该对象的一个引用保存到animals，此时只有一个引用指向animals，这个引用被封闭在局部变量中，从而实现线程封闭。\n\n## ThreadLocal类\n每个线程独有，避免变量共享；为每个线程创建一个副本；\n###实现原理\n定义了一个静态内部类ThreadLocalMap,key存的是threadLocal实例本身，value存的是副本变量；这样就达到了每个线程有单独的副本变量，实现了变量隔离。ThreadLocalMap采用了散列表，不同于HashMap，主要不同之处在于Hash冲突解决方案，hashmap当冲突时采用的是分离链表法，就是采用链表来存储冲突的value；而ThreadLocalMap采用的是开放定址法，当冲突时会再次做hash运算，知道找到空余的数组，这样做事因为threadLocalMap很少有Hash冲突；\n####分离链表法：\n![这里写图片描述](http://img.blog.csdn.net/20180408164032350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n####开放定址法\n![这里写图片描述](http://img.blog.csdn.net/20180408164105234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","source":"_posts/va并发编程-线程封闭.md","raw":"title: java并发编程--线程封闭\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-04-08 16:37:00\nsubtitle:\nheader-img:\n---\n#java并发编程--线程封闭\n\n线程封闭有三种方式：Ad-hoc线程封闭、栈封闭、ThreadLocal类；其中Ad-hoc线程封闭一般由程序员自己实现，很少用，暂不介绍。\n\n - 加粗    `Ctrl + B` \n - 插入代码    `Ctrl + K`\n\n\n## 栈封闭\n\n> 将对象封闭在局部变量中，只有局部变量才能访问，保证线程安全。 \n\n下面我们来看一段简单的代码\n\n```\npublic class Animals {\n    Ark ark;\n    Species species;\n    Gender gender;\n\n    public int loadTheArk(Collection<Animal> candidates) {\n        SortedSet<Animal> animals;\n        int numPairs = 0;\n        Animal candidate = null;\n\n        // 被封闭在局部方法中，不要让他溢出\n        animals = new TreeSet<Animal>(new SpeciesGenderComparator());\n        animals.addAll(candidates);\n        for (Animal a : animals) {\n            if (candidate == null || !candidate.isPotentialMate(a))\n                candidate = a;\n            else {\n                ark.load(new AnimalPair(candidate, a));\n                ++numPairs;\n                candidate = null;\n            }\n        }\n        return numPairs;\n    }\n\n\n    class Animal {\n        Species species;\n        Gender gender;\n\n        public boolean isPotentialMate(Animal other) {\n            return species == other.species && gender != other.gender;\n        }\n    }\n\n    enum Species {\n        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,\n        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,\n        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,\n        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA\n    }\n\n    enum Gender {\n        MALE, FEMALE\n    }\n\n    class AnimalPair {\n        private final Animal one, two;\n\n        public AnimalPair(Animal one, Animal two) {\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    class SpeciesGenderComparator implements Comparator<Animal> {\n        public int compare(Animal one, Animal two) {\n            int speciesCompare = one.species.compareTo(two.species);\n            return (speciesCompare != 0)\n                    ? speciesCompare\n                    : one.gender.compareTo(two.gender);\n        }\n    }\n\n    class Ark {\n        private final Set<AnimalPair> loadedAnimals = new HashSet<AnimalPair>();\n\n        public void load(AnimalPair pair) {\n            loadedAnimals.add(pair);\n        }\n    }\n}\n```\n\nanimals被封装在一个局部变量treeset中，并将指向该对象的一个引用保存到animals，此时只有一个引用指向animals，这个引用被封闭在局部变量中，从而实现线程封闭。\n\n## ThreadLocal类\n每个线程独有，避免变量共享；为每个线程创建一个副本；\n###实现原理\n定义了一个静态内部类ThreadLocalMap,key存的是threadLocal实例本身，value存的是副本变量；这样就达到了每个线程有单独的副本变量，实现了变量隔离。ThreadLocalMap采用了散列表，不同于HashMap，主要不同之处在于Hash冲突解决方案，hashmap当冲突时采用的是分离链表法，就是采用链表来存储冲突的value；而ThreadLocalMap采用的是开放定址法，当冲突时会再次做hash运算，知道找到空余的数组，这样做事因为threadLocalMap很少有Hash冲突；\n####分离链表法：\n![这里写图片描述](http://img.blog.csdn.net/20180408164032350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n####开放定址法\n![这里写图片描述](http://img.blog.csdn.net/20180408164105234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","slug":"va并发编程-线程封闭","published":1,"updated":"2019-06-29T08:40:28.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8i000okcx1bux0r8en","content":"<p>#java并发编程–线程封闭</p>\n<p>线程封闭有三种方式：Ad-hoc线程封闭、栈封闭、ThreadLocal类；其中Ad-hoc线程封闭一般由程序员自己实现，很少用，暂不介绍。</p>\n<ul>\n<li>加粗    <code>Ctrl + B</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n</ul>\n<h2><span id=\"栈封闭\">栈封闭</span></h2>\n<blockquote>\n<p>将对象封闭在局部变量中，只有局部变量才能访问，保证线程安全。</p>\n</blockquote>\n<p>下面我们来看一段简单的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Animals &#123;</span><br><span class=\"line\">    Ark ark;</span><br><span class=\"line\">    Species species;</span><br><span class=\"line\">    Gender gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int loadTheArk(Collection&lt;Animal&gt; candidates) &#123;</span><br><span class=\"line\">        SortedSet&lt;Animal&gt; animals;</span><br><span class=\"line\">        int numPairs = 0;</span><br><span class=\"line\">        Animal candidate = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 被封闭在局部方法中，不要让他溢出</span><br><span class=\"line\">        animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator());</span><br><span class=\"line\">        animals.addAll(candidates);</span><br><span class=\"line\">        for (Animal a : animals) &#123;</span><br><span class=\"line\">            if (candidate == null || !candidate.isPotentialMate(a))</span><br><span class=\"line\">                candidate = a;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                ark.load(new AnimalPair(candidate, a));</span><br><span class=\"line\">                ++numPairs;</span><br><span class=\"line\">                candidate = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return numPairs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    class Animal &#123;</span><br><span class=\"line\">        Species species;</span><br><span class=\"line\">        Gender gender;</span><br><span class=\"line\"></span><br><span class=\"line\">        public boolean isPotentialMate(Animal other) &#123;</span><br><span class=\"line\">            return species == other.species &amp;&amp; gender != other.gender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    enum Species &#123;</span><br><span class=\"line\">        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,</span><br><span class=\"line\">        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,</span><br><span class=\"line\">        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,</span><br><span class=\"line\">        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    enum Gender &#123;</span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class AnimalPair &#123;</span><br><span class=\"line\">        private final Animal one, two;</span><br><span class=\"line\"></span><br><span class=\"line\">        public AnimalPair(Animal one, Animal two) &#123;</span><br><span class=\"line\">            this.one = one;</span><br><span class=\"line\">            this.two = two;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class SpeciesGenderComparator implements Comparator&lt;Animal&gt; &#123;</span><br><span class=\"line\">        public int compare(Animal one, Animal two) &#123;</span><br><span class=\"line\">            int speciesCompare = one.species.compareTo(two.species);</span><br><span class=\"line\">            return (speciesCompare != 0)</span><br><span class=\"line\">                    ? speciesCompare</span><br><span class=\"line\">                    : one.gender.compareTo(two.gender);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Ark &#123;</span><br><span class=\"line\">        private final Set&lt;AnimalPair&gt; loadedAnimals = new HashSet&lt;AnimalPair&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        public void load(AnimalPair pair) &#123;</span><br><span class=\"line\">            loadedAnimals.add(pair);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>animals被封装在一个局部变量treeset中，并将指向该对象的一个引用保存到animals，此时只有一个引用指向animals，这个引用被封闭在局部变量中，从而实现线程封闭。</p>\n<h2><span id=\"threadlocal类\">ThreadLocal类</span></h2>\n<p>每个线程独有，避免变量共享；为每个线程创建一个副本；<br>\n###实现原理<br>\n定义了一个静态内部类ThreadLocalMap,key存的是threadLocal实例本身，value存的是副本变量；这样就达到了每个线程有单独的副本变量，实现了变量隔离。ThreadLocalMap采用了散列表，不同于HashMap，主要不同之处在于Hash冲突解决方案，hashmap当冲突时采用的是分离链表法，就是采用链表来存储冲突的value；而ThreadLocalMap采用的是开放定址法，当冲突时会再次做hash运算，知道找到空余的数组，这样做事因为threadLocalMap很少有Hash冲突；<br>\n####分离链表法：<br>\n<img src=\"http://img.blog.csdn.net/20180408164032350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####开放定址法<br>\n<img src=\"http://img.blog.csdn.net/20180408164105234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#java并发编程–线程封闭</p>\n<p>线程封闭有三种方式：Ad-hoc线程封闭、栈封闭、ThreadLocal类；其中Ad-hoc线程封闭一般由程序员自己实现，很少用，暂不介绍。</p>\n<ul>\n<li>加粗    <code>Ctrl + B</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n</ul>\n<h2>栈封闭</h2>\n<blockquote>\n<p>将对象封闭在局部变量中，只有局部变量才能访问，保证线程安全。</p>\n</blockquote>\n<p>下面我们来看一段简单的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Animals &#123;</span><br><span class=\"line\">    Ark ark;</span><br><span class=\"line\">    Species species;</span><br><span class=\"line\">    Gender gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int loadTheArk(Collection&lt;Animal&gt; candidates) &#123;</span><br><span class=\"line\">        SortedSet&lt;Animal&gt; animals;</span><br><span class=\"line\">        int numPairs = 0;</span><br><span class=\"line\">        Animal candidate = null;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 被封闭在局部方法中，不要让他溢出</span><br><span class=\"line\">        animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator());</span><br><span class=\"line\">        animals.addAll(candidates);</span><br><span class=\"line\">        for (Animal a : animals) &#123;</span><br><span class=\"line\">            if (candidate == null || !candidate.isPotentialMate(a))</span><br><span class=\"line\">                candidate = a;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                ark.load(new AnimalPair(candidate, a));</span><br><span class=\"line\">                ++numPairs;</span><br><span class=\"line\">                candidate = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return numPairs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    class Animal &#123;</span><br><span class=\"line\">        Species species;</span><br><span class=\"line\">        Gender gender;</span><br><span class=\"line\"></span><br><span class=\"line\">        public boolean isPotentialMate(Animal other) &#123;</span><br><span class=\"line\">            return species == other.species &amp;&amp; gender != other.gender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    enum Species &#123;</span><br><span class=\"line\">        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,</span><br><span class=\"line\">        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,</span><br><span class=\"line\">        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,</span><br><span class=\"line\">        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    enum Gender &#123;</span><br><span class=\"line\">        MALE, FEMALE</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class AnimalPair &#123;</span><br><span class=\"line\">        private final Animal one, two;</span><br><span class=\"line\"></span><br><span class=\"line\">        public AnimalPair(Animal one, Animal two) &#123;</span><br><span class=\"line\">            this.one = one;</span><br><span class=\"line\">            this.two = two;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class SpeciesGenderComparator implements Comparator&lt;Animal&gt; &#123;</span><br><span class=\"line\">        public int compare(Animal one, Animal two) &#123;</span><br><span class=\"line\">            int speciesCompare = one.species.compareTo(two.species);</span><br><span class=\"line\">            return (speciesCompare != 0)</span><br><span class=\"line\">                    ? speciesCompare</span><br><span class=\"line\">                    : one.gender.compareTo(two.gender);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Ark &#123;</span><br><span class=\"line\">        private final Set&lt;AnimalPair&gt; loadedAnimals = new HashSet&lt;AnimalPair&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        public void load(AnimalPair pair) &#123;</span><br><span class=\"line\">            loadedAnimals.add(pair);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>animals被封装在一个局部变量treeset中，并将指向该对象的一个引用保存到animals，此时只有一个引用指向animals，这个引用被封闭在局部变量中，从而实现线程封闭。</p>\n<h2>ThreadLocal类</h2>\n<p>每个线程独有，避免变量共享；为每个线程创建一个副本；<br>\n###实现原理<br>\n定义了一个静态内部类ThreadLocalMap,key存的是threadLocal实例本身，value存的是副本变量；这样就达到了每个线程有单独的副本变量，实现了变量隔离。ThreadLocalMap采用了散列表，不同于HashMap，主要不同之处在于Hash冲突解决方案，hashmap当冲突时采用的是分离链表法，就是采用链表来存储冲突的value；而ThreadLocalMap采用的是开放定址法，当冲突时会再次做hash运算，知道找到空余的数组，这样做事因为threadLocalMap很少有Hash冲突；<br>\n####分离链表法：<br>\n<img src=\"http://img.blog.csdn.net/20180408164032350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>####开放定址法<br>\n<img src=\"http://img.blog.csdn.net/20180408164105234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd21qNzY1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n"},{"title":"上传jar包到nexus私服","catalog":true,"author":"wangmj","date":"2019-03-18T09:03:00.000Z","subtitle":null,"header-img":null,"_content":"#### 上传jar包\n主要有两种方式，一个是网页上传，一个是命令行上传\n#### 网页上传\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190318161357654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n上传之后，将私服jar包同步到本地。在idea执行-U idea:idea。\n#### 通过命令上传\n首先修改maven的settings文件，添加用私服户名及密码，\n\n```\n\t<server>\n\t\t<id>releases</id>\n\t\t<username>admin</username>\n\t\t<password>admin</password>\n\t</server>\n\n\t<server>\n\t\t<id>snapshots</id>\n\t\t<username>admin</username>\n\t\t<password>admin</password>\n\t</server>\n  </servers>\n```\n之后在jar包所在目录执行以下命令\n```\nmvn deploy:deploy-file -DgroupId=com.qianhai -DartifactId=chainsdk -Dversion=1.3.4 -Dpackaging=jar -Dfile=chainsdk1.3.4.jar -Durl=http://10.144.137.112:8081/nexus/content/repositories/releases -DrepositoryId=releases\n```\n执行成功后同步到本地即可\n","source":"_posts/上传jar包到nexus私服.md","raw":"title: 上传jar包到nexus私服\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2019-03-18 17:03:00\nsubtitle:\nheader-img:\n---\n#### 上传jar包\n主要有两种方式，一个是网页上传，一个是命令行上传\n#### 网页上传\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190318161357654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70)\n上传之后，将私服jar包同步到本地。在idea执行-U idea:idea。\n#### 通过命令上传\n首先修改maven的settings文件，添加用私服户名及密码，\n\n```\n\t<server>\n\t\t<id>releases</id>\n\t\t<username>admin</username>\n\t\t<password>admin</password>\n\t</server>\n\n\t<server>\n\t\t<id>snapshots</id>\n\t\t<username>admin</username>\n\t\t<password>admin</password>\n\t</server>\n  </servers>\n```\n之后在jar包所在目录执行以下命令\n```\nmvn deploy:deploy-file -DgroupId=com.qianhai -DartifactId=chainsdk -Dversion=1.3.4 -Dpackaging=jar -Dfile=chainsdk1.3.4.jar -Durl=http://10.144.137.112:8081/nexus/content/repositories/releases -DrepositoryId=releases\n```\n执行成功后同步到本地即可\n","slug":"上传jar包到nexus私服","published":1,"updated":"2019-06-29T09:03:47.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8j000pkcx1de6bkrg4","content":"<h4><span id=\"上传jar包\">上传jar包</span></h4>\n<p>主要有两种方式，一个是网页上传，一个是命令行上传</p>\n<h4><span id=\"网页上传\">网页上传</span></h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190318161357654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n上传之后，将私服jar包同步到本地。在idea执行-U idea:idea。</p>\n<h4><span id=\"通过命令上传\">通过命令上传</span></h4>\n<p>首先修改maven的settings文件，添加用私服户名及密码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t&lt;id&gt;releases&lt;/id&gt;</span><br><span class=\"line\">\t&lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">\t&lt;password&gt;admin&lt;/password&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t&lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">\t&lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">\t&lt;password&gt;admin&lt;/password&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\"> &lt;/servers&gt;</span><br></pre></td></tr></table></figure>\n<p>之后在jar包所在目录执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn deploy:deploy-file -DgroupId=com.qianhai -DartifactId=chainsdk -Dversion=1.3.4 -Dpackaging=jar -Dfile=chainsdk1.3.4.jar -Durl=http://10.144.137.112:8081/nexus/content/repositories/releases -DrepositoryId=releases</span><br></pre></td></tr></table></figure>\n<p>执行成功后同步到本地即可</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>上传jar包</h4>\n<p>主要有两种方式，一个是网页上传，一个是命令行上传</p>\n<h4>网页上传</h4>\n<p><img src=\"https://img-blog.csdnimg.cn/20190318161357654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dtajc2NQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n上传之后，将私服jar包同步到本地。在idea执行-U idea:idea。</p>\n<h4>通过命令上传</h4>\n<p>首先修改maven的settings文件，添加用私服户名及密码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t&lt;id&gt;releases&lt;/id&gt;</span><br><span class=\"line\">\t&lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">\t&lt;password&gt;admin&lt;/password&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">\t&lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">\t&lt;username&gt;admin&lt;/username&gt;</span><br><span class=\"line\">\t&lt;password&gt;admin&lt;/password&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\"> &lt;/servers&gt;</span><br></pre></td></tr></table></figure>\n<p>之后在jar包所在目录执行以下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn deploy:deploy-file -DgroupId=com.qianhai -DartifactId=chainsdk -Dversion=1.3.4 -Dpackaging=jar -Dfile=chainsdk1.3.4.jar -Durl=http://10.144.137.112:8081/nexus/content/repositories/releases -DrepositoryId=releases</span><br></pre></td></tr></table></figure>\n<p>执行成功后同步到本地即可</p>\n"},{"title":"原子操作原理","catalog":true,"author":"wangmj","date":"2018-06-02T08:46:00.000Z","subtitle":null,"header-img":null,"_content":"### 处理器实现原子操作\n- **使用总线锁保证原子性**  \n我们知道处理器存在内存与缓存，当线程读取数据时，先会去取缓存中的数据，若没有再去内存中拿取数据，这样就会发生缓存中与内存中的数据不一致，从而导致不正确的结果。  \n为了得到正确的结果，可以在总线上加锁，也就是在内存与缓存上都加锁，也就是给处理器一个#LOCK信号，这样线程就可以独占锁\n\n- **使用缓存锁保证原子性**  \n锁的粒度减少\n\n### Java实现原子操作\n- **使用cas操作来实现锁**  \n\n```\n/**\n * 原子操作\n *\n * @author wangmj\n * @since 2018/12/26\n */\npublic class Counter {\n\n    private int i = 0;\n    private AtomicInteger atomicI = new AtomicInteger(0);\n\n    public static void main(String[] args) throws InterruptedException {\n        final Counter counter = new Counter();\n        List<Thread> ts = new ArrayList<>();\n        for (int j = 0; j < 100; j++) {\n            Thread t = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int k = 0; k < 10000; k++) {\n                        counter.unsafeCount();\n                        counter.safeCount();\n                    }\n                }\n            });\n            ts.add(t);\n        }\n        System.out.println(ts.size());\n        for (Thread t : ts) {\n            t.start();\n        }\n        //等待所有线程执行完成\n        for (Thread t : ts) {\n            t.join();\n        }\n\n        System.out.println(counter.i);\n        System.out.println(counter.atomicI.get());\n    }\n\n\n    private void unsafeCount() {\n        i++;\n    }\n\n    private void safeCount() {\n        while (true) {\n            int i = atomicI.get();\n            boolean compareAndSet = atomicI.compareAndSet(i, ++i);\n            if (compareAndSet) {\n                break;\n            }else {\n                System.out.println(\"发生并发访问i=\"+i);\n            }\n        }\n    }\n}\n\n```\n结果如下：\n> 998944\n1000000\n>\n\n可以看到没有cas操作的发生了错误\n\n- **cas操作三大问题**\n    - ABA问题  \n    当检查值发生多次变化，并且最终变回原结果(A-B-A)，则发生ABA问题,此时通常多添加一个版本号来标识（A1-B2-A3）,同时比较值与版本号，就可以避免ABA（AtomicStampedReferenc类）\n    - 循环开销大  \n    自旋CAS若长时间不成功，则会造成CPU内存大量消耗\n    - 只能保证一个共享变量CAS操作  \n    当多个共享操作同时CAS时，可以将多个共享变量组合在一个对象内，并用AtomicReference保证对象的原子性\n","source":"_posts/操作原理.md","raw":"title: 原子操作原理\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-06-02 16:46:00\nsubtitle:\nheader-img:\n---\n### 处理器实现原子操作\n- **使用总线锁保证原子性**  \n我们知道处理器存在内存与缓存，当线程读取数据时，先会去取缓存中的数据，若没有再去内存中拿取数据，这样就会发生缓存中与内存中的数据不一致，从而导致不正确的结果。  \n为了得到正确的结果，可以在总线上加锁，也就是在内存与缓存上都加锁，也就是给处理器一个#LOCK信号，这样线程就可以独占锁\n\n- **使用缓存锁保证原子性**  \n锁的粒度减少\n\n### Java实现原子操作\n- **使用cas操作来实现锁**  \n\n```\n/**\n * 原子操作\n *\n * @author wangmj\n * @since 2018/12/26\n */\npublic class Counter {\n\n    private int i = 0;\n    private AtomicInteger atomicI = new AtomicInteger(0);\n\n    public static void main(String[] args) throws InterruptedException {\n        final Counter counter = new Counter();\n        List<Thread> ts = new ArrayList<>();\n        for (int j = 0; j < 100; j++) {\n            Thread t = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int k = 0; k < 10000; k++) {\n                        counter.unsafeCount();\n                        counter.safeCount();\n                    }\n                }\n            });\n            ts.add(t);\n        }\n        System.out.println(ts.size());\n        for (Thread t : ts) {\n            t.start();\n        }\n        //等待所有线程执行完成\n        for (Thread t : ts) {\n            t.join();\n        }\n\n        System.out.println(counter.i);\n        System.out.println(counter.atomicI.get());\n    }\n\n\n    private void unsafeCount() {\n        i++;\n    }\n\n    private void safeCount() {\n        while (true) {\n            int i = atomicI.get();\n            boolean compareAndSet = atomicI.compareAndSet(i, ++i);\n            if (compareAndSet) {\n                break;\n            }else {\n                System.out.println(\"发生并发访问i=\"+i);\n            }\n        }\n    }\n}\n\n```\n结果如下：\n> 998944\n1000000\n>\n\n可以看到没有cas操作的发生了错误\n\n- **cas操作三大问题**\n    - ABA问题  \n    当检查值发生多次变化，并且最终变回原结果(A-B-A)，则发生ABA问题,此时通常多添加一个版本号来标识（A1-B2-A3）,同时比较值与版本号，就可以避免ABA（AtomicStampedReferenc类）\n    - 循环开销大  \n    自旋CAS若长时间不成功，则会造成CPU内存大量消耗\n    - 只能保证一个共享变量CAS操作  \n    当多个共享操作同时CAS时，可以将多个共享变量组合在一个对象内，并用AtomicReference保证对象的原子性\n","slug":"操作原理","published":1,"updated":"2019-06-29T08:49:08.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8k000qkcx1n38mh2e1","content":"<h3><span id=\"处理器实现原子操作\">处理器实现原子操作</span></h3>\n<ul>\n<li>\n<p><strong>使用总线锁保证原子性</strong><br>\n我们知道处理器存在内存与缓存，当线程读取数据时，先会去取缓存中的数据，若没有再去内存中拿取数据，这样就会发生缓存中与内存中的数据不一致，从而导致不正确的结果。<br>\n为了得到正确的结果，可以在总线上加锁，也就是在内存与缓存上都加锁，也就是给处理器一个#LOCK信号，这样线程就可以独占锁</p>\n</li>\n<li>\n<p><strong>使用缓存锁保证原子性</strong><br>\n锁的粒度减少</p>\n</li>\n</ul>\n<h3><span id=\"java实现原子操作\">Java实现原子操作</span></h3>\n<ul>\n<li><strong>使用cas操作来实现锁</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 原子操作</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2018/12/26</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Counter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int i = 0;</span><br><span class=\"line\">    private AtomicInteger atomicI = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final Counter counter = new Counter();</span><br><span class=\"line\">        List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class=\"line\">            Thread t = new Thread(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int k = 0; k &lt; 10000; k++) &#123;</span><br><span class=\"line\">                        counter.unsafeCount();</span><br><span class=\"line\">                        counter.safeCount();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ts.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(ts.size());</span><br><span class=\"line\">        for (Thread t : ts) &#123;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //等待所有线程执行完成</span><br><span class=\"line\">        for (Thread t : ts) &#123;</span><br><span class=\"line\">            t.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(counter.i);</span><br><span class=\"line\">        System.out.println(counter.atomicI.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void unsafeCount() &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void safeCount() &#123;</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            int i = atomicI.get();</span><br><span class=\"line\">            boolean compareAndSet = atomicI.compareAndSet(i, ++i);</span><br><span class=\"line\">            if (compareAndSet) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                System.out.println(&quot;发生并发访问i=&quot;+i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<blockquote>\n<p>998944<br>\n1000000</p>\n</blockquote>\n<p>可以看到没有cas操作的发生了错误</p>\n<ul>\n<li><strong>cas操作三大问题</strong>\n<ul>\n<li>ABA问题<br>\n当检查值发生多次变化，并且最终变回原结果(A-B-A)，则发生ABA问题,此时通常多添加一个版本号来标识（A1-B2-A3）,同时比较值与版本号，就可以避免ABA（AtomicStampedReferenc类）</li>\n<li>循环开销大<br>\n自旋CAS若长时间不成功，则会造成CPU内存大量消耗</li>\n<li>只能保证一个共享变量CAS操作<br>\n当多个共享操作同时CAS时，可以将多个共享变量组合在一个对象内，并用AtomicReference保证对象的原子性</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>处理器实现原子操作</h3>\n<ul>\n<li>\n<p><strong>使用总线锁保证原子性</strong><br>\n我们知道处理器存在内存与缓存，当线程读取数据时，先会去取缓存中的数据，若没有再去内存中拿取数据，这样就会发生缓存中与内存中的数据不一致，从而导致不正确的结果。<br>\n为了得到正确的结果，可以在总线上加锁，也就是在内存与缓存上都加锁，也就是给处理器一个#LOCK信号，这样线程就可以独占锁</p>\n</li>\n<li>\n<p><strong>使用缓存锁保证原子性</strong><br>\n锁的粒度减少</p>\n</li>\n</ul>\n<h3>Java实现原子操作</h3>\n<ul>\n<li><strong>使用cas操作来实现锁</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 原子操作</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2018/12/26</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Counter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int i = 0;</span><br><span class=\"line\">    private AtomicInteger atomicI = new AtomicInteger(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final Counter counter = new Counter();</span><br><span class=\"line\">        List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class=\"line\">            Thread t = new Thread(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int k = 0; k &lt; 10000; k++) &#123;</span><br><span class=\"line\">                        counter.unsafeCount();</span><br><span class=\"line\">                        counter.safeCount();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ts.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(ts.size());</span><br><span class=\"line\">        for (Thread t : ts) &#123;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //等待所有线程执行完成</span><br><span class=\"line\">        for (Thread t : ts) &#123;</span><br><span class=\"line\">            t.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(counter.i);</span><br><span class=\"line\">        System.out.println(counter.atomicI.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void unsafeCount() &#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void safeCount() &#123;</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            int i = atomicI.get();</span><br><span class=\"line\">            boolean compareAndSet = atomicI.compareAndSet(i, ++i);</span><br><span class=\"line\">            if (compareAndSet) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                System.out.println(&quot;发生并发访问i=&quot;+i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下：</p>\n<blockquote>\n<p>998944<br>\n1000000</p>\n</blockquote>\n<p>可以看到没有cas操作的发生了错误</p>\n<ul>\n<li><strong>cas操作三大问题</strong>\n<ul>\n<li>ABA问题<br>\n当检查值发生多次变化，并且最终变回原结果(A-B-A)，则发生ABA问题,此时通常多添加一个版本号来标识（A1-B2-A3）,同时比较值与版本号，就可以避免ABA（AtomicStampedReferenc类）</li>\n<li>循环开销大<br>\n自旋CAS若长时间不成功，则会造成CPU内存大量消耗</li>\n<li>只能保证一个共享变量CAS操作<br>\n当多个共享操作同时CAS时，可以将多个共享变量组合在一个对象内，并用AtomicReference保证对象的原子性</li>\n</ul>\n</li>\n</ul>\n"},{"title":"利用jstack打印线程dump信息","catalog":true,"author":"wangmj","date":"2018-07-01T08:47:00.000Z","subtitle":null,"header-img":null,"_content":"1.进入到jdk/bin目录\n\n2.jstack pid > /home/data/dump\n\n3.查看各线程状态下的数量\n\n\n\ngrep java.lang.Thread.State /home/data/dump9001 | awk '{print $2$3$4$5}' | sort |uniq -c\n\n\n\n4.分析：37个线程处于WAITING(onobjecmonitor)状态\n\n5.打开dump文件具体查看waiting状态线程都在干什么\n\n\n\n","source":"_posts/利用jstack打印线程dump信息.md","raw":"title: 利用jstack打印线程dump信息\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-07-01 16:47:00\nsubtitle:\nheader-img:\n---\n1.进入到jdk/bin目录\n\n2.jstack pid > /home/data/dump\n\n3.查看各线程状态下的数量\n\n\n\ngrep java.lang.Thread.State /home/data/dump9001 | awk '{print $2$3$4$5}' | sort |uniq -c\n\n\n\n4.分析：37个线程处于WAITING(onobjecmonitor)状态\n\n5.打开dump文件具体查看waiting状态线程都在干什么\n\n\n\n","slug":"利用jstack打印线程dump信息","published":1,"updated":"2019-06-29T08:50:48.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8k000rkcx1h2wkni9u","content":"<p>1.进入到jdk/bin目录</p>\n<p>2.jstack pid &gt; /home/data/dump</p>\n<p>3.查看各线程状态下的数量</p>\n<p>grep java.lang.Thread.State /home/data/dump9001 | awk ‘{print $2$3$4$5}’ | sort |uniq -c</p>\n<p>4.分析：37个线程处于WAITING(onobjecmonitor)状态</p>\n<p>5.打开dump文件具体查看waiting状态线程都在干什么</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.进入到jdk/bin目录</p>\n<p>2.jstack pid &gt; /home/data/dump</p>\n<p>3.查看各线程状态下的数量</p>\n<p>grep java.lang.Thread.State /home/data/dump9001 | awk ‘{print $2$3$4$5}’ | sort |uniq -c</p>\n<p>4.分析：37个线程处于WAITING(onobjecmonitor)状态</p>\n<p>5.打开dump文件具体查看waiting状态线程都在干什么</p>\n"},{"title":"算法与结构--插入排序","catalog":true,"author":"wangmj","date":"2019-03-16T09:02:00.000Z","subtitle":null,"header-img":null,"_content":"#### 前言\n万事万物皆算法，一切的始源与终点皆为**思想**。\n在介绍插入算法之前，我们来简单回顾上一篇学的选择排序，选择排序基本思路就是每次遍历找到最小的元素放在首位置，这样他的时间复杂度是n2，但是由于其交换的次数不是很多，他的时间并没有冒泡排序等n2时间大。那么我们本节学习的插入排序有什么优势和缺点呢，废话不多说，割了\n         ------------------------------------------------------\n#### 插入排序\n怎么记住插入排序呢，大家都玩过扑克牌，每次抓玩牌整理纸牌的时候都会挑选出小牌插入到该有的位置，这个工程和插入排序很像，我们先看下插入排序的动图。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316201145385.gif)\n从图上可以看出，他的时间复杂度也为n2,而且每次插入会导致后面的元素都交换位置，大家都知道，**数组交换位置相比遍历要耗时的多**，那么插入排序的优势在哪呢，我们先来写下代码，还是在上一篇的选择排序的基础上写。\n\n```\n    /**\n     * 插入排序\n     */\n    private static void insertSort(int arr[]) {\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i; j > 0; j--) {\n                if (arr[j] < arr[j - 1]) {\n                    SortHelper.swapArr(arr, j, j - 1);\n                }\n            }\n        }\n    }\n```\n代码很简单，我么从i=1开始最外层遍历，然后比较i之前两两元素的大小，符合就交换位置，这样就实现了排序，我们测试下选择排序和插入排序的时间对比吧，还是比较10000个元素的排序时间\n\n```\n\n/**\n * 选择排序\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortTest {\n    public static void main(String[] args) {\n        //随机生成区间内的正整数\n        int[] arr = SortHelper.generateArr(10000, 2, 30000);\n        //copy数据\n        int[] arr1 = Arrays.copyOf(arr, 10000);\n\n        //选择排序\n        long start = System.nanoTime();\n        selectionSort(arr);\n        long endTime = System.nanoTime();\n        System.out.println(\"selection time = \" + TimeUnit.NANOSECONDS.toMillis(endTime - start));\n        SortHelper.printer(arr);\n\n        //插入排序\n        long start1 = System.nanoTime();\n        insertSort(arr1);\n        long endTime1 = System.nanoTime();\n        System.out.println(\"insert time = \" + TimeUnit.NANOSECONDS.toMillis(endTime1 - start1));\n        SortHelper.printer(arr1);\n\n    }\n\n    /**\n     * 插入排序\n     */\n    private static void insertSort(int arr[]) {\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i; j > 0; j--) {\n                if (arr[j] < arr[j - 1]) {\n                    SortHelper.swapArr(arr, j, j - 1);\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * 选择排序\n     *\n     * @param arr 数组\n     */\n    private static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minIndex] > arr[j]) {\n                    minIndex = j;\n                }\n            }\n            SortHelper.swapArr(arr, i, minIndex);\n        }\n    }\n\n\n}\n\n```\n结果如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316202147611.png)\n可以看到选择排序的时间会比插入排序的小一点(大多数是，主要是看交换次数)。\n#### 改进插入排序\n那么插入排序为什么比较重要呢，我们先分析下为什么我们刚写的插入排序为什么这么慢呢，其实刚开始的时候我们已经介绍过，慢的原因无疑就是每次j遍历的时候，会比较j和j-1的大小，并且会交换，交换次数会特别多，那么我们怎么改进呢。\n这次我们比较之后不轻易交换位置，直到找到合适的位置在把i的元素放到j的位置\n\n```\n    /**\n     * 升级版插入排序\n     */\n    private static void insertSortPro(int arr[]) {\n        for (int i = 0; i < arr.length; i++) {\n            int value = arr[i];\n            int j;\n            for (j = i; j > 0 && arr[j - 1] > value; j--) {\n                arr[j] = arr[j - 1];\n            }\n            //说明没有过交换\n            if (j != i) {\n                arr[j] = value;\n            }\n        }\n    }\n```\n这次我们再次测试下三个排序的时间\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316202854150.png)\n可以看到，改进后的时间只有32ms，若是一个接近有序的数组，其时间会更低，时间复杂度也降低至接近n，此速度是非常快的\n#### 总结\n插入排序在改进后速度很快，他的时间复杂度n2，但是当数组接近有序的时候，其时间复杂度会接近为o(n)，这也导致很多复杂排序会在内部结合插入排序，因为其简单并且在某些情况下很高效，后面我们要学习的希尔排序就是插入排序的一种变种","source":"_posts/算法与结构-插入排序.md","raw":"title: 算法与结构--插入排序\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2019-03-16 17:02:00\nsubtitle:\nheader-img:\n---\n#### 前言\n万事万物皆算法，一切的始源与终点皆为**思想**。\n在介绍插入算法之前，我们来简单回顾上一篇学的选择排序，选择排序基本思路就是每次遍历找到最小的元素放在首位置，这样他的时间复杂度是n2，但是由于其交换的次数不是很多，他的时间并没有冒泡排序等n2时间大。那么我们本节学习的插入排序有什么优势和缺点呢，废话不多说，割了\n         ------------------------------------------------------\n#### 插入排序\n怎么记住插入排序呢，大家都玩过扑克牌，每次抓玩牌整理纸牌的时候都会挑选出小牌插入到该有的位置，这个工程和插入排序很像，我们先看下插入排序的动图。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316201145385.gif)\n从图上可以看出，他的时间复杂度也为n2,而且每次插入会导致后面的元素都交换位置，大家都知道，**数组交换位置相比遍历要耗时的多**，那么插入排序的优势在哪呢，我们先来写下代码，还是在上一篇的选择排序的基础上写。\n\n```\n    /**\n     * 插入排序\n     */\n    private static void insertSort(int arr[]) {\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i; j > 0; j--) {\n                if (arr[j] < arr[j - 1]) {\n                    SortHelper.swapArr(arr, j, j - 1);\n                }\n            }\n        }\n    }\n```\n代码很简单，我么从i=1开始最外层遍历，然后比较i之前两两元素的大小，符合就交换位置，这样就实现了排序，我们测试下选择排序和插入排序的时间对比吧，还是比较10000个元素的排序时间\n\n```\n\n/**\n * 选择排序\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortTest {\n    public static void main(String[] args) {\n        //随机生成区间内的正整数\n        int[] arr = SortHelper.generateArr(10000, 2, 30000);\n        //copy数据\n        int[] arr1 = Arrays.copyOf(arr, 10000);\n\n        //选择排序\n        long start = System.nanoTime();\n        selectionSort(arr);\n        long endTime = System.nanoTime();\n        System.out.println(\"selection time = \" + TimeUnit.NANOSECONDS.toMillis(endTime - start));\n        SortHelper.printer(arr);\n\n        //插入排序\n        long start1 = System.nanoTime();\n        insertSort(arr1);\n        long endTime1 = System.nanoTime();\n        System.out.println(\"insert time = \" + TimeUnit.NANOSECONDS.toMillis(endTime1 - start1));\n        SortHelper.printer(arr1);\n\n    }\n\n    /**\n     * 插入排序\n     */\n    private static void insertSort(int arr[]) {\n        for (int i = 1; i < arr.length; i++) {\n            for (int j = i; j > 0; j--) {\n                if (arr[j] < arr[j - 1]) {\n                    SortHelper.swapArr(arr, j, j - 1);\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * 选择排序\n     *\n     * @param arr 数组\n     */\n    private static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minIndex] > arr[j]) {\n                    minIndex = j;\n                }\n            }\n            SortHelper.swapArr(arr, i, minIndex);\n        }\n    }\n\n\n}\n\n```\n结果如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316202147611.png)\n可以看到选择排序的时间会比插入排序的小一点(大多数是，主要是看交换次数)。\n#### 改进插入排序\n那么插入排序为什么比较重要呢，我们先分析下为什么我们刚写的插入排序为什么这么慢呢，其实刚开始的时候我们已经介绍过，慢的原因无疑就是每次j遍历的时候，会比较j和j-1的大小，并且会交换，交换次数会特别多，那么我们怎么改进呢。\n这次我们比较之后不轻易交换位置，直到找到合适的位置在把i的元素放到j的位置\n\n```\n    /**\n     * 升级版插入排序\n     */\n    private static void insertSortPro(int arr[]) {\n        for (int i = 0; i < arr.length; i++) {\n            int value = arr[i];\n            int j;\n            for (j = i; j > 0 && arr[j - 1] > value; j--) {\n                arr[j] = arr[j - 1];\n            }\n            //说明没有过交换\n            if (j != i) {\n                arr[j] = value;\n            }\n        }\n    }\n```\n这次我们再次测试下三个排序的时间\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190316202854150.png)\n可以看到，改进后的时间只有32ms，若是一个接近有序的数组，其时间会更低，时间复杂度也降低至接近n，此速度是非常快的\n#### 总结\n插入排序在改进后速度很快，他的时间复杂度n2，但是当数组接近有序的时候，其时间复杂度会接近为o(n)，这也导致很多复杂排序会在内部结合插入排序，因为其简单并且在某些情况下很高效，后面我们要学习的希尔排序就是插入排序的一种变种","slug":"算法与结构-插入排序","published":1,"updated":"2019-06-29T09:03:04.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8l000skcx17t52xt43","content":"<h4><span id=\"前言\">前言</span></h4>\n<p>万事万物皆算法，一切的始源与终点皆为<strong>思想</strong>。<br>\n在介绍插入算法之前，我们来简单回顾上一篇学的选择排序，选择排序基本思路就是每次遍历找到最小的元素放在首位置，这样他的时间复杂度是n2，但是由于其交换的次数不是很多，他的时间并没有冒泡排序等n2时间大。那么我们本节学习的插入排序有什么优势和缺点呢，废话不多说，割了<br>\n------------------------------------------------------</p>\n<h4><span id=\"插入排序\">插入排序</span></h4>\n<p>怎么记住插入排序呢，大家都玩过扑克牌，每次抓玩牌整理纸牌的时候都会挑选出小牌插入到该有的位置，这个工程和插入排序很像，我们先看下插入排序的动图。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316201145385.gif\" alt=\"在这里插入图片描述\"><br>\n从图上可以看出，他的时间复杂度也为n2,而且每次插入会导致后面的元素都交换位置，大家都知道，<strong>数组交换位置相比遍历要耗时的多</strong>，那么插入排序的优势在哪呢，我们先来写下代码，还是在上一篇的选择排序的基础上写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 插入排序</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void insertSort(int arr[]) &#123;</span><br><span class=\"line\">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        for (int j = i; j &gt; 0; j--) &#123;</span><br><span class=\"line\">            if (arr[j] &lt; arr[j - 1]) &#123;</span><br><span class=\"line\">                SortHelper.swapArr(arr, j, j - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，我么从i=1开始最外层遍历，然后比较i之前两两元素的大小，符合就交换位置，这样就实现了排序，我们测试下选择排序和插入排序的时间对比吧，还是比较10000个元素的排序时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择排序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //随机生成区间内的正整数</span><br><span class=\"line\">        int[] arr = SortHelper.generateArr(10000, 2, 30000);</span><br><span class=\"line\">        //copy数据</span><br><span class=\"line\">        int[] arr1 = Arrays.copyOf(arr, 10000);</span><br><span class=\"line\"></span><br><span class=\"line\">        //选择排序</span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        long endTime = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;selection time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime - start));</span><br><span class=\"line\">        SortHelper.printer(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        //插入排序</span><br><span class=\"line\">        long start1 = System.nanoTime();</span><br><span class=\"line\">        insertSort(arr1);</span><br><span class=\"line\">        long endTime1 = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;insert time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime1 - start1));</span><br><span class=\"line\">        SortHelper.printer(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 插入排序</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void insertSort(int arr[]) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            for (int j = i; j &gt; 0; j--) &#123;</span><br><span class=\"line\">                if (arr[j] &lt; arr[j - 1]) &#123;</span><br><span class=\"line\">                    SortHelper.swapArr(arr, j, j - 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 选择排序</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                if (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SortHelper.swapArr(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316202147611.png\" alt=\"在这里插入图片描述\"><br>\n可以看到选择排序的时间会比插入排序的小一点(大多数是，主要是看交换次数)。</p>\n<h4><span id=\"改进插入排序\">改进插入排序</span></h4>\n<p>那么插入排序为什么比较重要呢，我们先分析下为什么我们刚写的插入排序为什么这么慢呢，其实刚开始的时候我们已经介绍过，慢的原因无疑就是每次j遍历的时候，会比较j和j-1的大小，并且会交换，交换次数会特别多，那么我们怎么改进呢。<br>\n这次我们比较之后不轻易交换位置，直到找到合适的位置在把i的元素放到j的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 升级版插入排序</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void insertSortPro(int arr[]) &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        int value = arr[i];</span><br><span class=\"line\">        int j;</span><br><span class=\"line\">        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; value; j--) &#123;</span><br><span class=\"line\">            arr[j] = arr[j - 1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //说明没有过交换</span><br><span class=\"line\">        if (j != i) &#123;</span><br><span class=\"line\">            arr[j] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次我们再次测试下三个排序的时间<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316202854150.png\" alt=\"在这里插入图片描述\"><br>\n可以看到，改进后的时间只有32ms，若是一个接近有序的数组，其时间会更低，时间复杂度也降低至接近n，此速度是非常快的</p>\n<h4><span id=\"总结\">总结</span></h4>\n<p>插入排序在改进后速度很快，他的时间复杂度n2，但是当数组接近有序的时候，其时间复杂度会接近为o(n)，这也导致很多复杂排序会在内部结合插入排序，因为其简单并且在某些情况下很高效，后面我们要学习的希尔排序就是插入排序的一种变种</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>前言</h4>\n<p>万事万物皆算法，一切的始源与终点皆为<strong>思想</strong>。<br>\n在介绍插入算法之前，我们来简单回顾上一篇学的选择排序，选择排序基本思路就是每次遍历找到最小的元素放在首位置，这样他的时间复杂度是n2，但是由于其交换的次数不是很多，他的时间并没有冒泡排序等n2时间大。那么我们本节学习的插入排序有什么优势和缺点呢，废话不多说，割了<br>\n------------------------------------------------------</p>\n<h4>插入排序</h4>\n<p>怎么记住插入排序呢，大家都玩过扑克牌，每次抓玩牌整理纸牌的时候都会挑选出小牌插入到该有的位置，这个工程和插入排序很像，我们先看下插入排序的动图。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316201145385.gif\" alt=\"在这里插入图片描述\"><br>\n从图上可以看出，他的时间复杂度也为n2,而且每次插入会导致后面的元素都交换位置，大家都知道，<strong>数组交换位置相比遍历要耗时的多</strong>，那么插入排序的优势在哪呢，我们先来写下代码，还是在上一篇的选择排序的基础上写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 插入排序</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void insertSort(int arr[]) &#123;</span><br><span class=\"line\">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        for (int j = i; j &gt; 0; j--) &#123;</span><br><span class=\"line\">            if (arr[j] &lt; arr[j - 1]) &#123;</span><br><span class=\"line\">                SortHelper.swapArr(arr, j, j - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码很简单，我么从i=1开始最外层遍历，然后比较i之前两两元素的大小，符合就交换位置，这样就实现了排序，我们测试下选择排序和插入排序的时间对比吧，还是比较10000个元素的排序时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择排序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //随机生成区间内的正整数</span><br><span class=\"line\">        int[] arr = SortHelper.generateArr(10000, 2, 30000);</span><br><span class=\"line\">        //copy数据</span><br><span class=\"line\">        int[] arr1 = Arrays.copyOf(arr, 10000);</span><br><span class=\"line\"></span><br><span class=\"line\">        //选择排序</span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        long endTime = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;selection time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime - start));</span><br><span class=\"line\">        SortHelper.printer(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        //插入排序</span><br><span class=\"line\">        long start1 = System.nanoTime();</span><br><span class=\"line\">        insertSort(arr1);</span><br><span class=\"line\">        long endTime1 = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;insert time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime1 - start1));</span><br><span class=\"line\">        SortHelper.printer(arr1);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 插入排序</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void insertSort(int arr[]) &#123;</span><br><span class=\"line\">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            for (int j = i; j &gt; 0; j--) &#123;</span><br><span class=\"line\">                if (arr[j] &lt; arr[j - 1]) &#123;</span><br><span class=\"line\">                    SortHelper.swapArr(arr, j, j - 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 选择排序</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                if (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SortHelper.swapArr(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果如下<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316202147611.png\" alt=\"在这里插入图片描述\"><br>\n可以看到选择排序的时间会比插入排序的小一点(大多数是，主要是看交换次数)。</p>\n<h4>改进插入排序</h4>\n<p>那么插入排序为什么比较重要呢，我们先分析下为什么我们刚写的插入排序为什么这么慢呢，其实刚开始的时候我们已经介绍过，慢的原因无疑就是每次j遍历的时候，会比较j和j-1的大小，并且会交换，交换次数会特别多，那么我们怎么改进呢。<br>\n这次我们比较之后不轻易交换位置，直到找到合适的位置在把i的元素放到j的位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 升级版插入排序</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void insertSortPro(int arr[]) &#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        int value = arr[i];</span><br><span class=\"line\">        int j;</span><br><span class=\"line\">        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; value; j--) &#123;</span><br><span class=\"line\">            arr[j] = arr[j - 1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //说明没有过交换</span><br><span class=\"line\">        if (j != i) &#123;</span><br><span class=\"line\">            arr[j] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次我们再次测试下三个排序的时间<br>\n<img src=\"https://img-blog.csdnimg.cn/20190316202854150.png\" alt=\"在这里插入图片描述\"><br>\n可以看到，改进后的时间只有32ms，若是一个接近有序的数组，其时间会更低，时间复杂度也降低至接近n，此速度是非常快的</p>\n<h4>总结</h4>\n<p>插入排序在改进后速度很快，他的时间复杂度n2，但是当数组接近有序的时候，其时间复杂度会接近为o(n)，这也导致很多复杂排序会在内部结合插入排序，因为其简单并且在某些情况下很高效，后面我们要学习的希尔排序就是插入排序的一种变种</p>\n"},{"title":"同步队列-AbstractQueuedSyncronizer","catalog":true,"author":"wangmj","date":"2018-07-19T08:51:00.000Z","subtitle":null,"header-img":null,"_content":"### 根据AQS自己实现一个独占锁\n\n```\n/**\n * 独占锁自定义实现\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class MutexLock {\n    //自定义内部类继承AQS\n    //独占锁只需实现tryAcquire与tryRelease方法\n    //共享锁需要实现tryAcquireShared与tryReleaseShared方法\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            //cas将state变为arg\n            if (compareAndSetState(0, arg)) {\n                //设置独占线程为当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            //若状态值为0，则说明锁已释放\n            if (getState() == 0)\n                throw new IllegalMonitorStateException();\n            //设置独占线程为空，并将state更新为0\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n\n}\n\n```\n以上代码实现了一个简单的独占锁，下面我们写个测试类来测试下是否生效\n\n```\n/**\n * 独占锁测试类\n *\n * @author wangmj\n * @since 2019/1/15\n */\npublic class MuxaLockTest {\n    //安全数\n    private int safeCount = 0;\n    //不安全数\n    private int unsafeCount = 0;\n    //自定义独占锁\n    private MutexLock lock = new MutexLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        MuxaLockTest lockTest = new MuxaLockTest();\n        for (int j = 0; j < 100; j++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        lockTest.safeCount();\n                        lockTest.unsafeCount();\n                    }\n                }\n            }).start();\n        }\n\n        //等待使所有线程都执行完毕\n        Thread.sleep(2000);\n\n        System.out.println(\"safeCount = \" + lockTest.safeCount);\n        System.out.println(\"unsafeCount = \" + lockTest.unsafeCount);\n\n    }\n\n    /**\n     * 加锁，线程安全\n     */\n    private void safeCount() {\n        lock.lock();\n        try {\n            safeCount++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * 不加锁，会造成线程安全问题\n     */\n    private void unsafeCount() {\n        unsafeCount++;\n    }\n}\n```\n测试结果若下\n\n```\nsafeCount = 100000\nunsafeCount = 99935\n```\n说明我们自己定义的独占锁生效，能让线程串行化执行。那么AQS的原理是什么呢？推荐大家看个文章，精髓就是下面这个图片。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118143707728.png)\n\n内部维护了一个队列，当tryAcquire获取失败时，会将此线程放入队列尾部，并且将线程park()等待，释放的时候会先将头结点unpark()，并将第二个节点变成头结点，相当于出队操作；中间有很多设计巧妙的细节，如放入队列的时候会先尝试快速直接将任务放置到队尾操作\n\n```\n//快速将任务放置到队尾\nif (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n```\n当快速失败的时候，会CAS自旋将队列入队，方法如下\n\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { // Must initialize\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\nAQS原理连接如下，讲的很详细很到位\n[Java并发之AQS详解](http://www.cnblogs.com/waterystone/p/4920797.html)","source":"_posts/步队列-AbstractQueuedSyncronizer.md","raw":"title: 同步队列-AbstractQueuedSyncronizer\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2018-07-19 16:51:00\nsubtitle:\nheader-img:\n---\n### 根据AQS自己实现一个独占锁\n\n```\n/**\n * 独占锁自定义实现\n *\n * @author wangmj\n * @since 2019/1/18\n */\npublic class MutexLock {\n    //自定义内部类继承AQS\n    //独占锁只需实现tryAcquire与tryRelease方法\n    //共享锁需要实现tryAcquireShared与tryReleaseShared方法\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            //cas将state变为arg\n            if (compareAndSetState(0, arg)) {\n                //设置独占线程为当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            //若状态值为0，则说明锁已释放\n            if (getState() == 0)\n                throw new IllegalMonitorStateException();\n            //设置独占线程为空，并将state更新为0\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n\n}\n\n```\n以上代码实现了一个简单的独占锁，下面我们写个测试类来测试下是否生效\n\n```\n/**\n * 独占锁测试类\n *\n * @author wangmj\n * @since 2019/1/15\n */\npublic class MuxaLockTest {\n    //安全数\n    private int safeCount = 0;\n    //不安全数\n    private int unsafeCount = 0;\n    //自定义独占锁\n    private MutexLock lock = new MutexLock();\n\n    public static void main(String[] args) throws InterruptedException {\n        MuxaLockTest lockTest = new MuxaLockTest();\n        for (int j = 0; j < 100; j++) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < 1000; i++) {\n                        lockTest.safeCount();\n                        lockTest.unsafeCount();\n                    }\n                }\n            }).start();\n        }\n\n        //等待使所有线程都执行完毕\n        Thread.sleep(2000);\n\n        System.out.println(\"safeCount = \" + lockTest.safeCount);\n        System.out.println(\"unsafeCount = \" + lockTest.unsafeCount);\n\n    }\n\n    /**\n     * 加锁，线程安全\n     */\n    private void safeCount() {\n        lock.lock();\n        try {\n            safeCount++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    /**\n     * 不加锁，会造成线程安全问题\n     */\n    private void unsafeCount() {\n        unsafeCount++;\n    }\n}\n```\n测试结果若下\n\n```\nsafeCount = 100000\nunsafeCount = 99935\n```\n说明我们自己定义的独占锁生效，能让线程串行化执行。那么AQS的原理是什么呢？推荐大家看个文章，精髓就是下面这个图片。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118143707728.png)\n\n内部维护了一个队列，当tryAcquire获取失败时，会将此线程放入队列尾部，并且将线程park()等待，释放的时候会先将头结点unpark()，并将第二个节点变成头结点，相当于出队操作；中间有很多设计巧妙的细节，如放入队列的时候会先尝试快速直接将任务放置到队尾操作\n\n```\n//快速将任务放置到队尾\nif (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n```\n当快速失败的时候，会CAS自旋将队列入队，方法如下\n\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { // Must initialize\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\nAQS原理连接如下，讲的很详细很到位\n[Java并发之AQS详解](http://www.cnblogs.com/waterystone/p/4920797.html)","slug":"步队列-AbstractQueuedSyncronizer","published":1,"updated":"2019-06-29T08:51:56.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8l000tkcx17cahlrmy","content":"<h3><span id=\"根据aqs自己实现一个独占锁\">根据AQS自己实现一个独占锁</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 独占锁自定义实现</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MutexLock &#123;</span><br><span class=\"line\">    //自定义内部类继承AQS</span><br><span class=\"line\">    //独占锁只需实现tryAcquire与tryRelease方法</span><br><span class=\"line\">    //共享锁需要实现tryAcquireShared与tryReleaseShared方法</span><br><span class=\"line\">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">            //cas将state变为arg</span><br><span class=\"line\">            if (compareAndSetState(0, arg)) &#123;</span><br><span class=\"line\">                //设置独占线程为当前线程</span><br><span class=\"line\">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">            //若状态值为0，则说明锁已释放</span><br><span class=\"line\">            if (getState() == 0)</span><br><span class=\"line\">                throw new IllegalMonitorStateException();</span><br><span class=\"line\">            //设置独占线程为空，并将state更新为0</span><br><span class=\"line\">            setExclusiveOwnerThread(null);</span><br><span class=\"line\">            setState(0);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean isHeldExclusively() &#123;</span><br><span class=\"line\">            return getState() == 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Sync sync = new Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unlock() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了一个简单的独占锁，下面我们写个测试类来测试下是否生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 独占锁测试类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/15</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MuxaLockTest &#123;</span><br><span class=\"line\">    //安全数</span><br><span class=\"line\">    private int safeCount = 0;</span><br><span class=\"line\">    //不安全数</span><br><span class=\"line\">    private int unsafeCount = 0;</span><br><span class=\"line\">    //自定义独占锁</span><br><span class=\"line\">    private MutexLock lock = new MutexLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        MuxaLockTest lockTest = new MuxaLockTest();</span><br><span class=\"line\">        for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class=\"line\">            new Thread(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">                        lockTest.safeCount();</span><br><span class=\"line\">                        lockTest.unsafeCount();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //等待使所有线程都执行完毕</span><br><span class=\"line\">        Thread.sleep(2000);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;safeCount = &quot; + lockTest.safeCount);</span><br><span class=\"line\">        System.out.println(&quot;unsafeCount = &quot; + lockTest.unsafeCount);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 加锁，线程安全</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void safeCount() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            safeCount++;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 不加锁，会造成线程安全问题</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void unsafeCount() &#123;</span><br><span class=\"line\">        unsafeCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果若下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">safeCount = 100000</span><br><span class=\"line\">unsafeCount = 99935</span><br></pre></td></tr></table></figure>\n<p>说明我们自己定义的独占锁生效，能让线程串行化执行。那么AQS的原理是什么呢？推荐大家看个文章，精髓就是下面这个图片。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190118143707728.png\" alt=\"在这里插入图片描述\"></p>\n<p>内部维护了一个队列，当tryAcquire获取失败时，会将此线程放入队列尾部，并且将线程park()等待，释放的时候会先将头结点unpark()，并将第二个节点变成头结点，相当于出队操作；中间有很多设计巧妙的细节，如放入队列的时候会先尝试快速直接将任务放置到队尾操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//快速将任务放置到队尾</span><br><span class=\"line\">if (pred != null) &#123;</span><br><span class=\"line\">            node.prev = pred;</span><br><span class=\"line\">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">                pred.next = node;</span><br><span class=\"line\">                return node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>当快速失败的时候，会CAS自旋将队列入队，方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Node enq(final Node node) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        if (t == null) &#123; // Must initialize</span><br><span class=\"line\">            if (compareAndSetHead(new Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            if (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                return t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AQS原理连接如下，讲的很详细很到位<br>\n<a href=\"http://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">Java并发之AQS详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>根据AQS自己实现一个独占锁</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 独占锁自定义实现</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/18</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MutexLock &#123;</span><br><span class=\"line\">    //自定义内部类继承AQS</span><br><span class=\"line\">    //独占锁只需实现tryAcquire与tryRelease方法</span><br><span class=\"line\">    //共享锁需要实现tryAcquireShared与tryReleaseShared方法</span><br><span class=\"line\">    private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">            //cas将state变为arg</span><br><span class=\"line\">            if (compareAndSetState(0, arg)) &#123;</span><br><span class=\"line\">                //设置独占线程为当前线程</span><br><span class=\"line\">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">            //若状态值为0，则说明锁已释放</span><br><span class=\"line\">            if (getState() == 0)</span><br><span class=\"line\">                throw new IllegalMonitorStateException();</span><br><span class=\"line\">            //设置独占线程为空，并将state更新为0</span><br><span class=\"line\">            setExclusiveOwnerThread(null);</span><br><span class=\"line\">            setState(0);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean isHeldExclusively() &#123;</span><br><span class=\"line\">            return getState() == 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Sync sync = new Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void unlock() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码实现了一个简单的独占锁，下面我们写个测试类来测试下是否生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 独占锁测试类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/1/15</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class MuxaLockTest &#123;</span><br><span class=\"line\">    //安全数</span><br><span class=\"line\">    private int safeCount = 0;</span><br><span class=\"line\">    //不安全数</span><br><span class=\"line\">    private int unsafeCount = 0;</span><br><span class=\"line\">    //自定义独占锁</span><br><span class=\"line\">    private MutexLock lock = new MutexLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        MuxaLockTest lockTest = new MuxaLockTest();</span><br><span class=\"line\">        for (int j = 0; j &lt; 100; j++) &#123;</span><br><span class=\"line\">            new Thread(new Runnable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void run() &#123;</span><br><span class=\"line\">                    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">                        lockTest.safeCount();</span><br><span class=\"line\">                        lockTest.unsafeCount();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //等待使所有线程都执行完毕</span><br><span class=\"line\">        Thread.sleep(2000);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;safeCount = &quot; + lockTest.safeCount);</span><br><span class=\"line\">        System.out.println(&quot;unsafeCount = &quot; + lockTest.unsafeCount);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 加锁，线程安全</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void safeCount() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            safeCount++;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 不加锁，会造成线程安全问题</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void unsafeCount() &#123;</span><br><span class=\"line\">        unsafeCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试结果若下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">safeCount = 100000</span><br><span class=\"line\">unsafeCount = 99935</span><br></pre></td></tr></table></figure>\n<p>说明我们自己定义的独占锁生效，能让线程串行化执行。那么AQS的原理是什么呢？推荐大家看个文章，精髓就是下面这个图片。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190118143707728.png\" alt=\"在这里插入图片描述\"></p>\n<p>内部维护了一个队列，当tryAcquire获取失败时，会将此线程放入队列尾部，并且将线程park()等待，释放的时候会先将头结点unpark()，并将第二个节点变成头结点，相当于出队操作；中间有很多设计巧妙的细节，如放入队列的时候会先尝试快速直接将任务放置到队尾操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//快速将任务放置到队尾</span><br><span class=\"line\">if (pred != null) &#123;</span><br><span class=\"line\">            node.prev = pred;</span><br><span class=\"line\">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">                pred.next = node;</span><br><span class=\"line\">                return node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>当快速失败的时候，会CAS自旋将队列入队，方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Node enq(final Node node) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        if (t == null) &#123; // Must initialize</span><br><span class=\"line\">            if (compareAndSetHead(new Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            if (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                return t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AQS原理连接如下，讲的很详细很到位<br>\n<a href=\"http://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">Java并发之AQS详解</a></p>\n"},{"title":"算法与结构--选择排序","catalog":true,"author":"wangmj","date":"2019-03-19T09:01:00.000Z","subtitle":null,"header-img":null,"_content":"#### 为什么要学习算法\n万事万物皆算法，Linus大神曾说过：“低水平程序员总在考虑代码,高水平程序员总在考虑数据结构及其之间的关系”。其实现实中无时无刻在接触算法，只不过很多算法被封装起来而没有在意，如果一味地写逻辑而不去考虑算法优化是不会有什么提高的。现在技术日新月异，我认为唯一能让你在以后的竞争中脱颖而出的就是算法。\n算法系列文章打算从简单的排序开始，此后逐渐升级，并且我们会分析此排序的优缺点，适应场景，并且会尝试优化排序，并给出测试用例。本节我们先简单分析下选择排序\n一切的始源与终点皆为**思想**。\n#### 公共方法\n在开始算法之前，我们先写一个辅助类，以后的辅助方法都会在此基础上添加或升级；方法如下\n\n```\nimport java.util.Arrays;\nimport java.util.Random;\n\n/**\n * 算法辅助类\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortHelper {\n\n    /**\n     * 生成个数为n,范围在[min~max]之间的数组\n     *\n     * @param n   数组个数\n     * @param min 最小数\n     * @param max 最大数\n     * @return 随机数组\n     */\n    public static int[] generateArr(int n, int min, int max) {\n        assert min <= max;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            Random random = new Random();\n            int value = random.nextInt(max - min) + min + 1;\n            arr[i] = value;\n        }\n        return arr;\n    }\n\n    /**\n     * 打印数组\n     *\n     * @param arr 数组\n     */\n    public static void printer(int arr[]) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    /**\n     * 交换数组元素\n     *\n     * @param arr    数组\n     * @param before 交换位置1\n     * @param after  交换位置2\n     */\n    public static void swapArr(int[] arr, int before, int after) {\n        int beforeVal = arr[before];\n        arr[before] = arr[after];\n        arr[after] = beforeVal;\n    }\n}\n\n```\n此辅助类主要包含三个方法，生成随机数组、交换两个元素、打印数组，很简单。\n\n#### 选择排序\n什么是选择排序，顾名思义就是每次遍历选择最小的那个然后放到头位置，然后下次遍历再次找到最小的元素放在第二个位置，以此类推，就成为了一个有序的数组。看下面的动图，可以清晰地看到他的时间复杂度为o(n2)。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190315155531244.gif)\n理解了思想代码就简单了\n\n```\n\n/**\n * 选择排序\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortTest {\n    public static void main(String[] args) {\n        //随机生成区间内的正整数\n        int[] arr = SortHelper.generateArr(10000, 2, 30000);\n\n        //选择排序\n        long start = System.nanoTime();\n        selectionSort(arr);\n        long endTime = System.nanoTime();\n        System.out.println(\"selection time = \" + TimeUnit.NANOSECONDS.toMillis(endTime - start));\n        SortHelper.printer(arr);\n    }\n\n    /**\n     * 选择排序\n     *\n     * @param arr 数组\n     */\n    private static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minIndex] > arr[j]) {\n                    minIndex = j;\n                }\n            }\n            SortHelper.swapArr(arr, i, minIndex);\n        }\n    }\n\n\n}\n\n```\n我们看下结果\n\n```\nselection time = 103\n[9, 13, 13, 16, 20, 21, 22, 24, 26, 31, 32, 45, 46, 47, 47, 50, 51, 52, 54, 56, 59, 60, 76, 78, 78, 81, 84, 84, 87, 91, 91, 93, 97...]\n```\n看到排序10000个随机数时间大概是103ms。\n\n#### 总结\n选择排序的时间复杂度为O(n2)，他的优点是交换次数较少(最多只需要交换n次)，相对于遍历交换数组中元素更加耗费时间，他的缺点也很明显，就是复杂度为n2，且基本不能优化\n","source":"_posts/算法与结构-选择排序.md","raw":"title: 算法与结构--选择排序\ncatalog: true\nauthor: wangmj\ntags: []\ncategories: []\ndate: 2019-03-19 17:01:00\nsubtitle:\nheader-img:\n---\n#### 为什么要学习算法\n万事万物皆算法，Linus大神曾说过：“低水平程序员总在考虑代码,高水平程序员总在考虑数据结构及其之间的关系”。其实现实中无时无刻在接触算法，只不过很多算法被封装起来而没有在意，如果一味地写逻辑而不去考虑算法优化是不会有什么提高的。现在技术日新月异，我认为唯一能让你在以后的竞争中脱颖而出的就是算法。\n算法系列文章打算从简单的排序开始，此后逐渐升级，并且我们会分析此排序的优缺点，适应场景，并且会尝试优化排序，并给出测试用例。本节我们先简单分析下选择排序\n一切的始源与终点皆为**思想**。\n#### 公共方法\n在开始算法之前，我们先写一个辅助类，以后的辅助方法都会在此基础上添加或升级；方法如下\n\n```\nimport java.util.Arrays;\nimport java.util.Random;\n\n/**\n * 算法辅助类\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortHelper {\n\n    /**\n     * 生成个数为n,范围在[min~max]之间的数组\n     *\n     * @param n   数组个数\n     * @param min 最小数\n     * @param max 最大数\n     * @return 随机数组\n     */\n    public static int[] generateArr(int n, int min, int max) {\n        assert min <= max;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            Random random = new Random();\n            int value = random.nextInt(max - min) + min + 1;\n            arr[i] = value;\n        }\n        return arr;\n    }\n\n    /**\n     * 打印数组\n     *\n     * @param arr 数组\n     */\n    public static void printer(int arr[]) {\n        System.out.println(Arrays.toString(arr));\n    }\n\n    /**\n     * 交换数组元素\n     *\n     * @param arr    数组\n     * @param before 交换位置1\n     * @param after  交换位置2\n     */\n    public static void swapArr(int[] arr, int before, int after) {\n        int beforeVal = arr[before];\n        arr[before] = arr[after];\n        arr[after] = beforeVal;\n    }\n}\n\n```\n此辅助类主要包含三个方法，生成随机数组、交换两个元素、打印数组，很简单。\n\n#### 选择排序\n什么是选择排序，顾名思义就是每次遍历选择最小的那个然后放到头位置，然后下次遍历再次找到最小的元素放在第二个位置，以此类推，就成为了一个有序的数组。看下面的动图，可以清晰地看到他的时间复杂度为o(n2)。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190315155531244.gif)\n理解了思想代码就简单了\n\n```\n\n/**\n * 选择排序\n *\n * @author wangmj\n * @since 2019/3/13\n */\npublic class SortTest {\n    public static void main(String[] args) {\n        //随机生成区间内的正整数\n        int[] arr = SortHelper.generateArr(10000, 2, 30000);\n\n        //选择排序\n        long start = System.nanoTime();\n        selectionSort(arr);\n        long endTime = System.nanoTime();\n        System.out.println(\"selection time = \" + TimeUnit.NANOSECONDS.toMillis(endTime - start));\n        SortHelper.printer(arr);\n    }\n\n    /**\n     * 选择排序\n     *\n     * @param arr 数组\n     */\n    private static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[minIndex] > arr[j]) {\n                    minIndex = j;\n                }\n            }\n            SortHelper.swapArr(arr, i, minIndex);\n        }\n    }\n\n\n}\n\n```\n我们看下结果\n\n```\nselection time = 103\n[9, 13, 13, 16, 20, 21, 22, 24, 26, 31, 32, 45, 46, 47, 47, 50, 51, 52, 54, 56, 59, 60, 76, 78, 78, 81, 84, 84, 87, 91, 91, 93, 97...]\n```\n看到排序10000个随机数时间大概是103ms。\n\n#### 总结\n选择排序的时间复杂度为O(n2)，他的优点是交换次数较少(最多只需要交换n次)，相对于遍历交换数组中元素更加耗费时间，他的缺点也很明显，就是复杂度为n2，且基本不能优化\n","slug":"算法与结构-选择排序","published":1,"updated":"2019-06-29T09:02:13.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxhh9p8m000ukcx12k5nluns","content":"<h4><span id=\"为什么要学习算法\">为什么要学习算法</span></h4>\n<p>万事万物皆算法，Linus大神曾说过：“低水平程序员总在考虑代码,高水平程序员总在考虑数据结构及其之间的关系”。其实现实中无时无刻在接触算法，只不过很多算法被封装起来而没有在意，如果一味地写逻辑而不去考虑算法优化是不会有什么提高的。现在技术日新月异，我认为唯一能让你在以后的竞争中脱颖而出的就是算法。<br>\n算法系列文章打算从简单的排序开始，此后逐渐升级，并且我们会分析此排序的优缺点，适应场景，并且会尝试优化排序，并给出测试用例。本节我们先简单分析下选择排序<br>\n一切的始源与终点皆为<strong>思想</strong>。</p>\n<h4><span id=\"公共方法\">公共方法</span></h4>\n<p>在开始算法之前，我们先写一个辅助类，以后的辅助方法都会在此基础上添加或升级；方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 算法辅助类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortHelper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 生成个数为n,范围在[min~max]之间的数组</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param n   数组个数</span><br><span class=\"line\">     * @param min 最小数</span><br><span class=\"line\">     * @param max 最大数</span><br><span class=\"line\">     * @return 随机数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int[] generateArr(int n, int min, int max) &#123;</span><br><span class=\"line\">        assert min &lt;= max;</span><br><span class=\"line\">        int[] arr = new int[n];</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Random random = new Random();</span><br><span class=\"line\">            int value = random.nextInt(max - min) + min + 1;</span><br><span class=\"line\">            arr[i] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 打印数组</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void printer(int arr[]) &#123;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 交换数组元素</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr    数组</span><br><span class=\"line\">     * @param before 交换位置1</span><br><span class=\"line\">     * @param after  交换位置2</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void swapArr(int[] arr, int before, int after) &#123;</span><br><span class=\"line\">        int beforeVal = arr[before];</span><br><span class=\"line\">        arr[before] = arr[after];</span><br><span class=\"line\">        arr[after] = beforeVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此辅助类主要包含三个方法，生成随机数组、交换两个元素、打印数组，很简单。</p>\n<h4><span id=\"选择排序\">选择排序</span></h4>\n<p>什么是选择排序，顾名思义就是每次遍历选择最小的那个然后放到头位置，然后下次遍历再次找到最小的元素放在第二个位置，以此类推，就成为了一个有序的数组。看下面的动图，可以清晰地看到他的时间复杂度为o(n2)。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190315155531244.gif\" alt=\"在这里插入图片描述\"><br>\n理解了思想代码就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择排序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //随机生成区间内的正整数</span><br><span class=\"line\">        int[] arr = SortHelper.generateArr(10000, 2, 30000);</span><br><span class=\"line\"></span><br><span class=\"line\">        //选择排序</span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        long endTime = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;selection time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime - start));</span><br><span class=\"line\">        SortHelper.printer(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 选择排序</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                if (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SortHelper.swapArr(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看下结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection time = 103</span><br><span class=\"line\">[9, 13, 13, 16, 20, 21, 22, 24, 26, 31, 32, 45, 46, 47, 47, 50, 51, 52, 54, 56, 59, 60, 76, 78, 78, 81, 84, 84, 87, 91, 91, 93, 97...]</span><br></pre></td></tr></table></figure>\n<p>看到排序10000个随机数时间大概是103ms。</p>\n<h4><span id=\"总结\">总结</span></h4>\n<p>选择排序的时间复杂度为O(n2)，他的优点是交换次数较少(最多只需要交换n次)，相对于遍历交换数组中元素更加耗费时间，他的缺点也很明显，就是复杂度为n2，且基本不能优化</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>为什么要学习算法</h4>\n<p>万事万物皆算法，Linus大神曾说过：“低水平程序员总在考虑代码,高水平程序员总在考虑数据结构及其之间的关系”。其实现实中无时无刻在接触算法，只不过很多算法被封装起来而没有在意，如果一味地写逻辑而不去考虑算法优化是不会有什么提高的。现在技术日新月异，我认为唯一能让你在以后的竞争中脱颖而出的就是算法。<br>\n算法系列文章打算从简单的排序开始，此后逐渐升级，并且我们会分析此排序的优缺点，适应场景，并且会尝试优化排序，并给出测试用例。本节我们先简单分析下选择排序<br>\n一切的始源与终点皆为<strong>思想</strong>。</p>\n<h4>公共方法</h4>\n<p>在开始算法之前，我们先写一个辅助类，以后的辅助方法都会在此基础上添加或升级；方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\">import java.util.Random;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 算法辅助类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortHelper &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 生成个数为n,范围在[min~max]之间的数组</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param n   数组个数</span><br><span class=\"line\">     * @param min 最小数</span><br><span class=\"line\">     * @param max 最大数</span><br><span class=\"line\">     * @return 随机数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int[] generateArr(int n, int min, int max) &#123;</span><br><span class=\"line\">        assert min &lt;= max;</span><br><span class=\"line\">        int[] arr = new int[n];</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            Random random = new Random();</span><br><span class=\"line\">            int value = random.nextInt(max - min) + min + 1;</span><br><span class=\"line\">            arr[i] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 打印数组</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void printer(int arr[]) &#123;</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 交换数组元素</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr    数组</span><br><span class=\"line\">     * @param before 交换位置1</span><br><span class=\"line\">     * @param after  交换位置2</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void swapArr(int[] arr, int before, int after) &#123;</span><br><span class=\"line\">        int beforeVal = arr[before];</span><br><span class=\"line\">        arr[before] = arr[after];</span><br><span class=\"line\">        arr[after] = beforeVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此辅助类主要包含三个方法，生成随机数组、交换两个元素、打印数组，很简单。</p>\n<h4>选择排序</h4>\n<p>什么是选择排序，顾名思义就是每次遍历选择最小的那个然后放到头位置，然后下次遍历再次找到最小的元素放在第二个位置，以此类推，就成为了一个有序的数组。看下面的动图，可以清晰地看到他的时间复杂度为o(n2)。<br>\n<img src=\"https://img-blog.csdnimg.cn/20190315155531244.gif\" alt=\"在这里插入图片描述\"><br>\n理解了思想代码就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择排序</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author wangmj</span><br><span class=\"line\"> * @since 2019/3/13</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SortTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        //随机生成区间内的正整数</span><br><span class=\"line\">        int[] arr = SortHelper.generateArr(10000, 2, 30000);</span><br><span class=\"line\"></span><br><span class=\"line\">        //选择排序</span><br><span class=\"line\">        long start = System.nanoTime();</span><br><span class=\"line\">        selectionSort(arr);</span><br><span class=\"line\">        long endTime = System.nanoTime();</span><br><span class=\"line\">        System.out.println(&quot;selection time = &quot; + TimeUnit.NANOSECONDS.toMillis(endTime - start));</span><br><span class=\"line\">        SortHelper.printer(arr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 选择排序</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param arr 数组</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void selectionSort(int[] arr) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            int minIndex = i;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">                if (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SortHelper.swapArr(arr, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看下结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection time = 103</span><br><span class=\"line\">[9, 13, 13, 16, 20, 21, 22, 24, 26, 31, 32, 45, 46, 47, 47, 50, 51, 52, 54, 56, 59, 60, 76, 78, 78, 81, 84, 84, 87, 91, 91, 93, 97...]</span><br></pre></td></tr></table></figure>\n<p>看到排序10000个随机数时间大概是103ms。</p>\n<h4>总结</h4>\n<p>选择排序的时间复杂度为O(n2)，他的优点是交换次数较少(最多只需要交换n次)，相对于遍历交换数组中元素更加耗费时间，他的缺点也很明显，就是复杂度为n2，且基本不能优化</p>\n"}],"PostAsset":[{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","slug":"home_posts_tag-false.png","post":"cjxhh9p830009kcx17lya320u","modified":1,"renderable":0},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjxhh9p87000akcx131dwp3ku","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjxhh9p830009kcx17lya320u","modified":1,"renderable":0},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjxhh9p8i000nkcx1y63vvrz8","modified":1,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","slug":"Demo.png","post":"cjxhh9p830009kcx17lya320u","modified":1,"renderable":0},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/Demo.png","slug":"Demo.png","post":"cjxhh9p87000akcx131dwp3ku","modified":1,"renderable":0},{"_id":"source/_posts/ava基础之集合框架-Collection及Map顶级接口/home_posts_tag-false.png","post":"cjxhh9p87000akcx131dwp3ku","slug":"home_posts_tag-false.png","modified":1,"renderable":1},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/Demo.png","slug":"Demo.png","post":"cjxhh9p8i000nkcx1y63vvrz8","modified":1,"renderable":0},{"_id":"source/_posts/ysql-拆分以逗号隔开的字段并应用在in查询/home_posts_tag-false.png","post":"cjxhh9p8i000nkcx1y63vvrz8","slug":"home_posts_tag-false.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjxhh9p830009kcx17lya320u","tag_id":"cjxhh9p89000bkcx1kwua4hlo","_id":"cjxhh9p8g000jkcx1yw8z7nvw"},{"post_id":"cjxhh9p830009kcx17lya320u","tag_id":"cjxhh9p8d000fkcx1xmd7pspf","_id":"cjxhh9p8h000lkcx1997tqjmb"}],"Tag":[{"name":"Hexo","_id":"cjxhh9p89000bkcx1kwua4hlo"},{"name":"Blog","_id":"cjxhh9p8d000fkcx1xmd7pspf"}]}}