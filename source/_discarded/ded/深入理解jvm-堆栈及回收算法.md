title: 深入理解jvm--堆栈及回收算法
catalog: true
author: wangmj
date: 2019-06-29 16:40:22
subtitle:
header-img:
tags:
---
堆内存：主要是存放数据，是存储单元；可以理解为内存，存放的是对象数据；-Xms:初始堆大小 -Xmx:最大堆大小

栈内存：运行单元，一个线程对应一个栈，主要存放基本数据类型及对象的引用；因为基本数据类型和对象引用（4bytes）大小固定

为什么要区分堆和栈呢？

1.堆的作用主要是数据存储，栈中主要是运行时所需，这样堆中一些常量数据可以在多个线程（栈内存）中共享，节省空间；

2.栈是运行时所需，数据动态增长消耗大，放在堆中更合理

3.垃圾回收只需找到栈中对象的引用，从而去找到堆中的对象，减少遍历负担



垃圾回收算法：

1.标记--清除



步骤：首先遍历查询所有有引用的对象进行标记，第二步遍历堆，把所有未标记的对象进行清除

缺点：会产生内存碎片 需要暂停应用



2.复制



步骤：需要同样大小的内存，先遍历所有的引用对象并进行复制，复制的同时进行碎片的整理

缺点：需要两倍大小的内存



3.标记--整理





步骤；结合上面两种的算法，先遍历所有有引用的对象并对其标记；遍历所有堆中没有被引用的对象 并清除；对内存进行重新整理；

缺点：复杂性提高



分代垃圾处理：

1.年轻代：存放刚创建的对象，并且生命周期较短的对象；分为三个区，Eden/S0/S1三个区域；

刚创建的对象存在Eden区，当Eden区满后，会存在S0或者S1一个区域，当Eden区域满

就会触发垃圾回收Minor GC,用上面的某种算法将还存活的对象放在S1中；

2.年老代：当S1中对象不能存放下时，就会把对象放在年老代中，因此年老代一般存放生命周期

较长的对象,当年老代满了后，就会触发FULL GC，

3.持久代：方法区的一种实现



典型配置：

java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -

XX:ParallelGCThreads=20

-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻

代使用并发收集，而年老代仍旧使用串行收集。

-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。

此值最好配置与处理器数目相等。

java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -

XX:ParallelGCThreads=20 -XX:+UseParallelOldGC

-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。

java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -

XX:MaxGCPauseMillis=100

-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会

自动调整年轻代大小，以满足此值。



jvm调优工具：

Jconsole JProfile VisualVm

















